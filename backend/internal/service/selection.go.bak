package service

import (
	"context"
	"fmt"

	"terraforming-mars-backend/internal/features/card"
	"terraforming-mars-backend/internal/game"
	"terraforming-mars-backend/internal/logger"
	"terraforming-mars-backend/internal/player"

	"go.uber.org/zap"
)

// SelectionManager handles all card selection operations
type SelectionManager struct {
	gameRepo         game.Repository
	playerRepo       player.Repository
	cardRepo         card.CardRepository
	cardDeckRepo     card.CardDeckRepository
	effectSubscriber CardEffectSubscriber
}

// NewSelectionManager creates a new card selection manager
func NewSelectionManager(gameRepo game.Repository, playerRepo player.Repository, cardRepo card.CardRepository, cardDeckRepo card.CardDeckRepository, effectSubscriber CardEffectSubscriber) *SelectionManager {
	return &SelectionManager{
		gameRepo:         gameRepo,
		playerRepo:       playerRepo,
		cardRepo:         cardRepo,
		cardDeckRepo:     cardDeckRepo,
		effectSubscriber: effectSubscriber,
	}
}

// SelectStartingCards handles the starting card and corporation selection for a player
func (s *SelectionManager) SelectStartingCards(ctx context.Context, gameID, playerID string, cardIDs []string, corporationID string) error {
	log := logger.WithGameContext(gameID, playerID)
	log.Debug("Processing starting card and corporation selection",
		zap.Strings("card_ids", cardIDs),
		zap.String("corporation_id", corporationID))

	// Validate the card selection
	if err := s.ValidateStartingCardSelection(ctx, gameID, playerID, cardIDs); err != nil {
		log.Error("Starting card selection validation failed", zap.Error(err))
		return fmt.Errorf("invalid card selection: %w", err)
	}

	// Get current player
	player, err := s.playerRepo.GetByID(ctx, gameID, playerID)
	if err != nil {
		log.Error("Failed to get player", zap.Error(err))
		return fmt.Errorf("failed to get player: %w", err)
	}

	// Validate and apply corporation selection
	if err := s.applyCorporationSelection(ctx, gameID, playerID, corporationID, &player); err != nil {
		log.Error("Corporation selection failed", zap.Error(err))
		return fmt.Errorf("corporation selection failed: %w", err)
	}

	// Calculate cost (3 MC per card)
	cost := len(cardIDs) * 3

	// Check if player can afford the selection
	if resources.Resources.Credits < cost {
		return fmt.Errorf("insufficient credits: need %d, have %d", cost, resources.Resources.Credits)
	}

	// Update player resources immediately (deduct credits)
	updatedResources := resources.Resources
	updatedResources.Credits -= cost
	if err := s.playerRepo.UpdateResources(ctx, gameID, playerID, updatedResources); err != nil {
		log.Error("Failed to update player resources", zap.Error(err))
		return fmt.Errorf("failed to update player resources: %w", err)
	}

	// Add selected cards to player's hand immediately using granular updates
	for _, cardID := range cardIDs {
		if err := s.playerRepo.AddCard(ctx, gameID, playerID, cardID); err != nil {
			log.Error("Failed to add card to player hand", zap.String("card_id", cardID), zap.Error(err))
			return fmt.Errorf("failed to add card %s: %w", cardID, err)
		}
	}

	// Clear the starting selection (this hides the modal)
	if err := s.playerRepo.SetStartingCardsSelectionComplete(ctx, gameID, playerID); err != nil {
		log.Error("Failed to clear starting selection", zap.Error(err))
		return fmt.Errorf("failed to clear starting selection: %w", err)
	}

	log.Info("Player starting card selection completed",
		zap.Strings("selected_cards", cardIDs),
		zap.Int("cost", cost))

	return nil
}

// SelectProductionCards handles the card selection during production phase
func (s *SelectionManager) SelectProductionCards(ctx context.Context, gameID, playerID string, cardIDs []string) error {
	log := logger.WithGameContext(gameID, playerID)
	log.Debug("Processing production card selection", zap.Strings("card_ids", cardIDs))

	// Validate the selection
	if err := s.ValidateProductionCardSelection(ctx, gameID, playerID, cardIDs); err != nil {
		log.Error("Production card selection validation failed", zap.Error(err))
		return fmt.Errorf("invalid card selection: %w", err)
	}

	// Get current player
	player, err := s.playerRepo.GetByID(ctx, gameID, playerID)
	if err != nil {
		log.Error("Failed to get player", zap.Error(err))
		return fmt.Errorf("failed to get player: %w", err)
	}

	// Calculate cost (3 MC per card)
	cost := len(cardIDs) * 3

	// Check if player can afford the selection
	if resources.Resources.Credits < cost {
		return fmt.Errorf("insufficient credits: need %d, have %d", cost, resources.Resources.Credits)
	}

	// Update player resources immediately (deduct credits)
	updatedResources := resources.Resources
	updatedResources.Credits -= cost
	if err := s.playerRepo.UpdateResources(ctx, gameID, playerID, updatedResources); err != nil {
		log.Error("Failed to update player resources", zap.Error(err))
		return fmt.Errorf("failed to update player resources: %w", err)
	}

	// Add selected cards to player's hand using granular updates
	for _, cardID := range cardIDs {
		if err := s.playerRepo.AddCard(ctx, gameID, playerID, cardID); err != nil {
			log.Error("Failed to add card to player hand", zap.String("card_id", cardID), zap.Error(err))
			return fmt.Errorf("failed to add card %s: %w", cardID, err)
		}
	}

	// Mark player as ready for production phase
	err = s.playerRepo.SetProductionCardsSelectionComplete(ctx, gameID, playerID)
	if err != nil {
		log.Error("Failed to mark production card selection complete", zap.Error(err))
		return fmt.Errorf("failed to mark production card selection complete: %w", err)
	}

	log.Info("Player production card selection completed",
		zap.Strings("selected_cards", cardIDs),
		zap.Int("cost", cost))

	return nil
}

// ValidateStartingCardSelection validates a player's starting card selection
func (s *SelectionManager) ValidateStartingCardSelection(ctx context.Context, gameID, playerID string, cardIDs []string) error {
	log := logger.WithGameContext(gameID, playerID)

	// Get current player to check starting card selection state
	player, err := s.playerRepo.GetByID(ctx, gameID, playerID)
	if err != nil {
		return fmt.Errorf("failed to get player: %w", err)
	}

	// Check if player already has cards in hand (indicating they already completed selection)
	if len(player.Cards) > 0 {
		log.Debug("Player has cards in hand, selection already completed", zap.Int("cards_in_hand", len(player.Cards)))
		return fmt.Errorf("starting card selection already completed - you have %d cards in your hand", len(player.Cards))
	}

	if player.SelectStartingCardsPhase == nil {
		return fmt.Errorf("starting card selection phase not initialized for player")
	}

	// Check if player has starting cards available for selection
	if len(player.SelectStartingCardsPhase.AvailableCards) == 0 {
		log.Debug("Player has no starting cards available",
			zap.Int("cards_in_hand", len(player.Cards)),
			zap.Bool("has_starting_selection", len(player.SelectStartingCardsPhase.AvailableCards) > 0))
		return fmt.Errorf("no starting cards available for selection - selection phase may have ended")
	}

	playerOptions := player.SelectStartingCardsPhase.AvailableCards

	// Check maximum cards (10 is the maximum starting cards dealt)
	if len(cardIDs) > 10 {
		return fmt.Errorf("cannot select more than 10 cards, got %d", len(cardIDs))
	}

	// Validate card IDs exist in the starting cards pool first
	allStartingCards, err := s.cardRepo.GetStartingCardPool(ctx)
	if err != nil {
		return fmt.Errorf("failed to get starting card pool: %w", err)
	}
	cardMap := make(map[string]bool)
	for _, card := range allStartingCards {
		cardMap[card.ID] = true
	}

	for _, cardID := range cardIDs {
		if !cardMap[cardID] {
			return fmt.Errorf("invalid card ID: %s", cardID)
		}
	}

	// Then validate selected cards are in player's options
	optionsMap := make(map[string]bool)
	for _, cardId := range playerOptions {
		optionsMap[cardId] = true
	}

	for _, cardID := range cardIDs {
		if !optionsMap[cardID] {
			return fmt.Errorf("card %s is not in player's available options", cardID)
		}
	}

	return nil
}

// ValidateProductionCardSelection validates a player's production card selection
func (s *SelectionManager) ValidateProductionCardSelection(ctx context.Context, gameID, playerID string, cardIDs []string) error {
	log := logger.WithGameContext(gameID, playerID)

	// Get current player to check production card selection state
	player, err := s.playerRepo.GetByID(ctx, gameID, playerID)
	if err != nil {
		return fmt.Errorf("failed to get player: %w", err)
	}

	if resources.ProductionPhase == nil {
		return fmt.Errorf("production card selection phase not initialized for player")
	}

	// Check if player has production cards available for selection
	if len(resources.ProductionPhase.AvailableCards) == 0 {
		log.Debug("Player has no production cards available")
		return fmt.Errorf("no production cards available for selection - selection phase may have ended")
	}

	playerOptions := resources.ProductionPhase.AvailableCards

	// Validate card IDs exist in the general card pool (production cards can be any card, not just starting cards)
	allCards, err := s.cardRepo.GetAllCards(ctx)
	if err != nil {
		return fmt.Errorf("failed to get card pool: %w", err)
	}
	cardMap := make(map[string]bool)
	for _, card := range allCards {
		cardMap[card.ID] = true
	}

	for _, cardID := range cardIDs {
		if !cardMap[cardID] {
			return fmt.Errorf("invalid card ID: %s", cardID)
		}
	}

	// Then validate selected cards are in player's available options
	optionsMap := make(map[string]bool)
	for _, cardId := range playerOptions {
		optionsMap[cardId] = true
	}

	for _, cardID := range cardIDs {
		if !optionsMap[cardID] {
			return fmt.Errorf("card %s is not in player's available options", cardID)
		}
	}

	return nil
}

// IsAllPlayersCardSelectionComplete checks if all players in the game have completed card selection
func (s *SelectionManager) IsAllPlayersCardSelectionComplete(ctx context.Context, gameID string) bool {
	log := logger.WithGameContext(gameID, "")

	// Get current game state to determine which selection type to check
	game, err := s.gameRepo.GetByID(ctx, gameID)
	if err != nil {
		log.Error("Failed to get game for selection completion check", zap.Error(err))
		return false
	}

	// Get all players in the game
	players, err := s.playerRepo.ListByGameID(ctx, gameID)
	if err != nil {
		log.Error("Failed to get players for selection completion check", zap.Error(err))
		return false
	}

	// If no players exist, selection is not complete
	if len(players) == 0 {
		return false
	}

	// Check completion based on current game phase
	switch game.CurrentPhase {
	case model.GamePhaseStartingCardSelection:
		return s.checkStartingCardSelectionComplete(players, log)
	case model.GamePhaseProductionAndCardDraw:
		return s.checkProductionCardSelectionComplete(players)
	default:
		// For other phases, assume no card selection is needed
		return true
	}
}

// checkStartingCardSelectionComplete checks if all players have completed starting card selection using the flag
func (s *SelectionManager) checkStartingCardSelectionComplete(players []model.Player, log *zap.Logger) bool {
	playersCompleted := 0

	// Check the HasSelectedStartingCards flag for each player
	for _, player := range players {
		if player.SelectStartingCardsPhase == nil {
			log.Debug("Player has no starting card selection phase initialized", zap.String("player_id", player.ID))
			continue
		}

		if player.SelectStartingCardsPhase.SelectionComplete {
			playersCompleted++
			log.Debug("Player has completed starting card selection", zap.String("player_id", player.ID))
		} else if len(player.SelectStartingCardsPhase.AvailableCards) > 0 {
			log.Debug("Player has starting selection but hasn't completed yet", zap.String("player_id", player.ID))
		} else {
			log.Debug("Player has no starting selection", zap.String("player_id", player.ID))
		}
	}

	// All players must have completed their starting card selection
	allComplete := playersCompleted == len(players)
	log.Debug("Starting card selection completion check",
		zap.Int("total_players", len(players)),
		zap.Int("players_completed", playersCompleted),
		zap.Bool("all_complete", allComplete))

	return allComplete
}

// checkProductionCardSelectionComplete checks production card selection completion
func (s *SelectionManager) checkProductionCardSelectionComplete(players []model.Player) bool {
	// Track selection states
	playersWithIncompleteSelection := 0
	playersWithSelectionData := 0

	// Check each player's selection status
	for _, player := range players {
		if resources.ProductionPhase != nil {
			playersWithSelectionData++
			// If any player has selection data but hasn't completed, selection is not done
			if !resources.ProductionPhase.SelectionComplete {
				playersWithIncompleteSelection++
			}
		}
	}

	// If any player has incomplete selection, overall selection is not complete
	if playersWithIncompleteSelection > 0 {
		return false
	}

	// If no players have selection data at all, selection is not complete
	// This handles the case where the selection phase hasn't been initiated yet
	if playersWithSelectionData == 0 {
		return false
	}

	// If we reach here, all players with selection data have completed selection
	return true
}

// ClearGameSelectionData clears temporary selection data for a game (called after selection phase completes)
func (s *SelectionManager) ClearGameSelectionData(gameID string) {
	ctx := context.Background()

	// Get all players in the game and clear their selection data
	players, err := s.playerRepo.ListByGameID(ctx, gameID)
	if err != nil {
		logger.WithGameContext(gameID, "").Error("Failed to get players for clearing selection data", zap.Error(err))
		return
	}

	for _, player := range players {
		if player.SelectStartingCardsPhase != nil {
			err = s.playerRepo.UpdateSelectStartingCardsPhase(ctx, gameID, player.ID, nil)
			if err != nil {
				logger.WithGameContext(gameID, player.ID).Error("Failed to clear starting card selection data", zap.Error(err))
				return
			}
		}

		if resources.ProductionPhase != nil {

			err = s.playerRepo.UpdateProductionPhase(ctx, gameID, player.ID, nil)
			if err != nil {
				logger.WithGameContext(gameID, player.ID).Error("Failed to clear production phase data", zap.Error(err))
				return
			}
		}
	}

	logger.WithGameContext(gameID, "").Debug("Cleared game selection data")
}

// extractForcedFirstAction parses a corporation's forced first action from its behaviors
// Forced first actions use auto-first-action trigger type (e.g., Inventrix: draw 3 cards, Tharsis: place city)
func (s *SelectionManager) extractForcedFirstAction(corporation *model.Card) *model.ForcedFirstAction {
	for _, behavior := range corporation.Behaviors {
		// Check if this behavior has a forced first action trigger
		for _, trigger := range behavior.Triggers {
			if trigger.Type == model.ResourceTriggerAutoFirstAction {
				// Determine action type from outputs
				actionType := s.determineActionType(behavior.Outputs)
				description := s.generateForcedActionDescription(behavior.Outputs)

				return &model.ForcedFirstAction{
					ActionType:    actionType,
					CorporationID: corporation.ID,
					Completed:     false,
					Description:   description,
				}
			}
		}
	}
	return nil
}

// determineActionType extracts the primary action type from behavior outputs
func (s *SelectionManager) determineActionType(outputs []model.ResourceCondition) string {
	if len(outputs) == 0 {
		return "unknown"
	}

	// Return the first output type as the action type
	switch outputs[0].Type {
	case "card-draw":
		return "card_draw"
	case "city-placement":
		return "city_placement"
	case "greenery-placement":
		return "greenery_placement"
	case "card-take":
		return "card_selection"
	default:
		return string(outputs[0].Type)
	}
}

// generateForcedActionDescription creates a human-readable description from outputs
func (s *SelectionManager) generateForcedActionDescription(outputs []model.ResourceCondition) string {
	if len(outputs) == 0 {
		return "Complete forced action"
	}

	// Generate description based on output type
	switch outputs[0].Type {
	case "card-draw":
		return fmt.Sprintf("Draw %d cards", outputs[0].Amount)
	case "city-placement":
		return "Place a city tile"
	case "greenery-placement":
		return "Place a greenery tile"
	case "card-take":
		return fmt.Sprintf("Select %d cards", outputs[0].Amount)
	default:
		return fmt.Sprintf("Complete %s action", outputs[0].Type)
	}
}

// applyCorporationSelection validates and applies corporation selection during starting card phase
func (s *SelectionManager) applyCorporationSelection(ctx context.Context, gameID, playerID, corporationID string, player *model.Player) error {
	log := logger.WithGameContext(gameID, playerID)

	// Validate player is in starting card selection phase
	if player.SelectStartingCardsPhase == nil {
		return fmt.Errorf("player not in starting card selection phase")
	}

	// Validate player hasn't already selected a corporation
	if player.Corporation != nil {
		log.Warn("Player has already selected a corporation", zap.String("existing_corporation", player.Corporation.Name))
		return fmt.Errorf("corporation already selected")
	}

	// Validate corporation is in player's available options
	corporationFound := false
	for _, availableCorp := range player.SelectStartingCardsPhase.AvailableCorporations {
		if availableCorp == corporationID {
			corporationFound = true
			break
		}
	}

	if !corporationFound {
		log.Warn("Corporation not in player's available options", zap.String("corporation_id", corporationID))
		return fmt.Errorf("corporation %s not in available options", corporationID)
	}

	// Get corporation details from card repository
	corporationCard, err := s.cardRepo.GetCardByID(ctx, corporationID)
	if err != nil {
		log.Error("Failed to get corporation card", zap.Error(err))
		return fmt.Errorf("failed to get corporation card: %w", err)
	}

	// Update player's corporation with full card object
	if err := s.playerRepo.UpdateCorporation(ctx, gameID, playerID, *corporationCard); err != nil {
		log.Error("Failed to update player corporation", zap.Error(err))
		return fmt.Errorf("failed to update player corporation: %w", err)
	}

	// Accumulate starting bonuses from both dedicated fields and behaviors
	// Start with empty structs - corporation bonuses REPLACE default starting values
	updatedResources := model.Resources{}
	updatedProduction := model.Production{}

	// Apply starting bonuses from parsed fields
	// Note: The card repository has already extracted immediate behaviors (auto trigger without condition)
	// into StartingResources and StartingProduction fields, so we don't need to process behaviors again
	if corporationCard.StartingResources != nil {
		updatedResources.Credits += corporationCard.StartingResources.Credits
		updatedResources.Steel += corporationCard.StartingResources.Steel
		updatedResources.Titanium += corporationCard.StartingResources.Titanium
		updatedResources.Plants += corporationCard.StartingResources.Plants
		updatedResources.Energy += corporationCard.StartingResources.Energy
		updatedResources.Heat += corporationCard.StartingResources.Heat
	}
	if corporationCard.StartingProduction != nil {
		updatedProduction.Credits += corporationCard.StartingProduction.Credits
		updatedProduction.Steel += corporationCard.StartingProduction.Steel
		updatedProduction.Titanium += corporationCard.StartingProduction.Titanium
		updatedProduction.Plants += corporationCard.StartingProduction.Plants
		updatedProduction.Energy += corporationCard.StartingProduction.Energy
		updatedProduction.Heat += corporationCard.StartingProduction.Heat
	}

	// Update player with accumulated resources and production from behaviors
	if err := s.playerRepo.UpdateResources(ctx, gameID, playerID, updatedResources); err != nil {
		log.Error("Failed to update player resources from behaviors", zap.Error(err))
		return fmt.Errorf("failed to update player resources from behaviors: %w", err)
	}

	if err := s.playerRepo.UpdateProduction(ctx, gameID, playerID, updatedProduction); err != nil {
		log.Error("Failed to update player production from behaviors", zap.Error(err))
		return fmt.Errorf("failed to update player production from behaviors: %w", err)
	}

	// Update player object for subsequent operations
	resources.Resources = updatedResources
	resources.Production = updatedProduction

	// Extract and apply payment substitutes from corporation behaviors
	paymentSubstitutes := []types.PaymentSubstitute{}
	for _, behavior := range corporationCard.Behaviors {
		// Look for auto-trigger behaviors without conditions (starting bonuses)
		hasAutoTrigger := false
		hasCondition := false
		for _, trigger := range behavior.Triggers {
			if trigger.Type == model.ResourceTriggerAuto {
				hasAutoTrigger = true
				if trigger.Condition != nil {
					hasCondition = true
				}
			}
		}

		// Only process auto behaviors without conditions (starting bonuses)
		if !hasAutoTrigger || hasCondition {
			continue
		}

		// Extract payment-substitute outputs
		for _, output := range behavior.Outputs {
			if output.Type == model.ResourcePaymentSubstitute {
				// Extract the resource type from affectedResources
				if len(output.AffectedResources) > 0 {
					resourceTypeStr := output.AffectedResources[0]
					substitute := types.PaymentSubstitute{
						ResourceType:   types.ResourceType(resourceTypeStr),
						ConversionRate: output.Amount,
					}
					paymentSubstitutes = append(paymentSubstitutes, substitute)
					log.Debug("ðŸ’° Extracted payment substitute from corporation",
						zap.String("resource_type", resourceTypeStr),
						zap.Int("conversion_rate", output.Amount))
				}
			}
		}
	}

	// Apply payment substitutes to player if any were found
	if len(paymentSubstitutes) > 0 {
		if err := s.playerRepo.UpdatePaymentSubstitutes(ctx, gameID, playerID, paymentSubstitutes); err != nil {
			log.Error("Failed to update player payment substitutes", zap.Error(err))
			return fmt.Errorf("failed to update player payment substitutes: %w", err)
		}
		log.Info("ðŸ’° Payment substitutes applied",
			zap.String("corporation_name", corporationCard.Name),
			zap.Int("substitutes_count", len(paymentSubstitutes)))
	}

	// Subscribe corporation passive effects using CardEffectSubscriber (event-driven system)
	if s.effectSubscriber != nil {
		if err := s.effectSubscriber.SubscribeCardEffects(ctx, gameID, playerID, corporationCard.ID, corporationCard); err != nil {
			return fmt.Errorf("failed to subscribe corporation effects: %w", err)
		}
		log.Info("ðŸŽ† Corporation passive effects subscribed",
			zap.String("corporation_name", corporationCard.Name))
	}

	// Extract and register corporation manual actions (manual triggers)
	// IMPORTANT: Skip forced first actions - they're handled separately below
	var manualActions []model.PlayerAction
	for behaviorIndex, behavior := range corporationCard.Behaviors {
		// Check if this behavior has manual triggers or auto-first-action triggers
		hasManualTrigger := false
		isAutoFirstAction := false
		for _, trigger := range behavior.Triggers {
			if trigger.Type == model.ResourceTriggerManual {
				hasManualTrigger = true
			}
			if trigger.Type == model.ResourceTriggerAutoFirstAction {
				isAutoFirstAction = true
			}
		}

		// If behavior has manual triggers (and is NOT a forced first action), create a PlayerAction
		// Forced first actions (auto-first-action) are handled separately via ForcedFirstAction system
		if hasManualTrigger {
			action := model.PlayerAction{
				CardID:        corporationCard.ID,
				CardName:      corporationCard.Name,
				BehaviorIndex: behaviorIndex,
				Behavior:      behavior,
			}
			manualActions = append(manualActions, action)
			log.Debug("ðŸŽ¯ Extracted manual action from corporation",
				zap.String("corporation_name", corporationCard.Name),
				zap.Int("behavior_index", behaviorIndex))
		} else if isAutoFirstAction {
			log.Debug("â­ï¸ Skipping forced first action (will be handled separately)",
				zap.String("corporation_name", corporationCard.Name),
				zap.Int("behavior_index", behaviorIndex))
		}
	}

	// Add manual actions to player if any were found
	if len(manualActions) > 0 {
		// Get current player state to append to existing actions
		currentPlayer, err := s.playerRepo.GetByID(ctx, gameID, playerID)
		if err != nil {
			return fmt.Errorf("failed to get player for actions update: %w", err)
		}

		// Create new actions list with existing + new corporation actions
		newActions := make([]model.PlayerAction, len(currentPlayer.Actions)+len(manualActions))
		copy(newActions, currentPlayer.Actions)
		copy(newActions[len(currentPlayer.Actions):], manualActions)

		// Update player with new actions
		if err := s.playerRepo.UpdatePlayerActions(ctx, gameID, playerID, newActions); err != nil {
			return fmt.Errorf("failed to update player manual actions: %w", err)
		}

		log.Info("ðŸŽ¯ Corporation manual actions registered",
			zap.String("corporation_name", corporationCard.Name),
			zap.Int("actions_count", len(manualActions)))
	}

	startingCredits := 0
	if corporationCard.StartingResources != nil {
		startingCredits = corporationCard.StartingResources.Credits
	}

	// Check if corporation requires a forced first turn action by parsing behaviors
	// (e.g., Inventrix: draw 3 cards, Tharsis Republic: place city, Philares: place greenery)
	forcedAction := s.extractForcedFirstAction(corporationCard)
	if forcedAction != nil {
		// Set forced first action flag - this action MUST be taken on the player's first turn

		if err := s.playerRepo.UpdateForcedFirstAction(ctx, gameID, playerID, forcedAction); err != nil {
			log.Error("Failed to set forced first action", zap.Error(err))
			return fmt.Errorf("failed to set forced first action: %w", err)
		}

		log.Info("ðŸŽ¯ Corporation requires forced first turn action",
			zap.String("corporation_id", corporationID),
			zap.String("action_type", forcedAction.ActionType),
			zap.String("description", forcedAction.Description))
	}

	log.Info("âœ… Corporation selected and bonuses applied",
		zap.String("corporation_id", corporationID),
		zap.String("corporation_name", corporationCard.Name),
		zap.Int("starting_credits", startingCredits))

	return nil
}
