// Code generated by tygo. DO NOT EDIT.

//////////
// source: actions_dto.go

/**
 * ActionType represents different types of game actions
 */
export type ActionType = string;
export const ActionTypeSelectStartingCard: ActionType = "select-starting-card";
export const ActionTypeSelectCards: ActionType = "select-cards";
export const ActionTypeStartGame: ActionType = "start-game";
export const ActionTypeSkipAction: ActionType = "skip-action";
export const ActionTypePlayCard: ActionType = "play-card";
export const ActionTypeCardAction: ActionType = "card-action";
/**
 * Standard Projects (M€-based)
 */
export const ActionTypeSellPatents: ActionType = "sell-patents";
export const ActionTypeBuildPowerPlant: ActionType = "build-power-plant";
export const ActionTypeLaunchAsteroid: ActionType = "launch-asteroid";
export const ActionTypeBuildAquifer: ActionType = "build-aquifer";
export const ActionTypePlantGreenery: ActionType = "plant-greenery";
export const ActionTypeBuildCity: ActionType = "build-city";
/**
 * Resource Conversion Actions
 */
export const ActionTypeConvertPlantsToGreenery: ActionType =
  "convert-plants-to-greenery";
export const ActionTypeConvertHeatToTemperature: ActionType =
  "convert-heat-to-temperature";
/**
 * SelectStartingCardAction represents selecting starting cards and corporation
 */
export interface SelectStartingCardAction {
  type: ActionType;
  cardIds: string[];
  corporationId: string;
}
/**
 * StartGameAction represents starting the game (host only)
 */
export interface StartGameAction {
  type: ActionType;
}
/**
 * SkipAction represents skipping a player's turn
 */
export interface SkipAction {
  type: ActionType;
}
/**
 * PlayCardAction represents playing a card from hand
 */
export interface PlayCardAction {
  cardId: string;
  payment: CardPaymentDto; // Required: payment breakdown (credits, steel, titanium)
  choiceIndex?: number /* int */; // Optional: index of choice to play (for cards with choices)
  cardStorageTarget?: string; // Optional: target card ID for resource storage (for outputs with target "any-card")
}
/**
 * PlayCardActionAction represents playing a card action from player's action list
 */
export interface PlayCardActionAction {
  cardId: string;
  behaviorIndex: number /* int */;
  choiceIndex?: number /* int */; // Optional: index of choice to play (for actions with choices)
  cardStorageTarget?: string; // Optional: target card ID for resource storage (for outputs with target "any-card")
}
/**
 * HexPositionDto represents a position on the Mars board
 */
export interface HexPositionDto {
  q: number /* int */;
  r: number /* int */;
  s: number /* int */;
}
/**
 * SellPatentsAction represents selling patent cards for megacredits (initiates card selection)
 */
export interface SellPatentsAction {
  type: ActionType;
}
/**
 * BuildPowerPlantAction represents building a power plant
 */
export interface BuildPowerPlantAction {
  type: ActionType;
}
/**
 * LaunchAsteroidAction represents launching an asteroid
 */
export interface LaunchAsteroidAction {
  type: ActionType;
}
/**
 * BuildAquiferAction represents building an aquifer
 */
export interface BuildAquiferAction {
  type: ActionType;
  hexPosition: HexPositionDto;
}
/**
 * PlantGreeneryAction represents planting greenery
 */
export interface PlantGreeneryAction {
  type: ActionType;
  hexPosition: HexPositionDto;
}
/**
 * BuildCityAction represents building a city
 */
export interface BuildCityAction {
  type: ActionType;
  hexPosition: HexPositionDto;
}
/**
 * ActionSelectStartingCardRequest contains the action data for select starting card actions
 */
export interface ActionSelectStartingCardRequest {
  type: ActionType;
  cardIds: string[];
  corporationId: string; // Corporation selected alongside starting cards
}
/**
 * ActionSelectProductionCardsRequest contains the action data for select production card actions
 */
export interface ActionSelectProductionCardsRequest {
  type: ActionType;
  cardIds: string[];
}
/**
 * ActionStartGameRequest contains the action data for start game actions
 */
export interface ActionStartGameRequest {
  type: ActionType;
}
/**
 * ActionSkipActionRequest contains the action data for skip action actions
 */
export interface ActionSkipActionRequest {
  type: ActionType;
}
/**
 * ActionPlayCardRequest contains the action data for play card actions
 */
export interface ActionPlayCardRequest {
  type: ActionType;
  cardId: string;
  payment: CardPaymentDto; // Required: payment breakdown (credits, steel, titanium)
  choiceIndex?: number /* int */; // Optional: index of choice to play (for cards with choices)
  cardStorageTarget?: string; // Optional: target card ID for resource storage (for outputs with target "any-card")
}
/**
 * ActionPlayCardActionRequest contains the action data for play card action actions
 */
export interface ActionPlayCardActionRequest {
  type: ActionType;
  cardId: string;
  behaviorIndex: number /* int */;
  choiceIndex?: number /* int */; // Optional: index of choice to play (for actions with choices)
  cardStorageTarget?: string; // Optional: target card ID for resource storage (for outputs with target "any-card")
}
/**
 * ActionSellPatentsRequest contains the action data for sell patents actions (initiates card selection)
 */
export interface ActionSellPatentsRequest {
  type: ActionType;
}
/**
 * ActionBuildPowerPlantRequest contains the action data for build power plant actions
 */
export interface ActionBuildPowerPlantRequest {
  type: ActionType;
}
/**
 * ActionLaunchAsteroidRequest contains the action data for launch asteroid actions
 */
export interface ActionLaunchAsteroidRequest {
  type: ActionType;
}
/**
 * ActionBuildAquiferRequest contains the action data for build aquifer actions
 */
export interface ActionBuildAquiferRequest {
  type: ActionType;
  hexPosition: HexPositionDto;
}
/**
 * ActionPlantGreeneryRequest contains the action data for plant greenery actions
 */
export interface ActionPlantGreeneryRequest {
  type: ActionType;
  hexPosition: HexPositionDto;
}
/**
 * ActionBuildCityRequest contains the action data for build city actions
 */
export interface ActionBuildCityRequest {
  type: ActionType;
  hexPosition: HexPositionDto;
}
/**
 * AdminCommandType represents different types of admin commands
 */
export type AdminCommandType = string;
export const AdminCommandTypeGiveCard: AdminCommandType = "give-card";
export const AdminCommandTypeSetPhase: AdminCommandType = "set-phase";
export const AdminCommandTypeSetResources: AdminCommandType = "set-resources";
export const AdminCommandTypeSetProduction: AdminCommandType = "set-production";
export const AdminCommandTypeSetGlobalParams: AdminCommandType =
  "set-global-params";
export const AdminCommandTypeStartTileSelection: AdminCommandType =
  "start-tile-selection";
export const AdminCommandTypeSetCurrentTurn: AdminCommandType =
  "set-current-turn";
/**
 * AdminCommandRequest contains the admin command data
 */
export interface AdminCommandRequest {
  commandType: AdminCommandType;
  payload: any;
}
/**
 * GiveCardAdminCommand represents giving a card to a player
 */
export interface GiveCardAdminCommand {
  playerId: string;
  cardId: string;
}
/**
 * SetPhaseAdminCommand represents setting the game phase
 */
export interface SetPhaseAdminCommand {
  phase: string;
}
/**
 * SetResourcesAdminCommand represents setting a player's resources
 */
export interface SetResourcesAdminCommand {
  playerId: string;
  resources: ResourcesDto;
}
/**
 * SetProductionAdminCommand represents setting a player's production
 */
export interface SetProductionAdminCommand {
  playerId: string;
  production: ProductionDto;
}
/**
 * SetGlobalParamsAdminCommand represents setting global parameters
 */
export interface SetGlobalParamsAdminCommand {
  globalParameters: GlobalParametersDto;
}
/**
 * StartTileSelectionAdminCommand represents starting tile selection for testing
 */
export interface StartTileSelectionAdminCommand {
  playerId: string;
  tileType: string;
}
/**
 * CardPaymentDto represents how a player is paying for a card
 */
export interface CardPaymentDto {
  credits: number /* int */; // MC spent
  steel: number /* int */; // Steel resources used (2 MC value each)
  titanium: number /* int */; // Titanium resources used (3 MC value each)
}

//////////
// source: game_dto.go

/**
 * GamePhase represents the current phase of the game
 */
export type GamePhase = string;
export const GamePhaseWaitingForGameStart: GamePhase = "waiting_for_game_start";
export const GamePhaseStartingCardSelection: GamePhase =
  "starting_card_selection";
export const GamePhaseStartGameSelection: GamePhase = "start_game_selection";
export const GamePhaseAction: GamePhase = "action";
export const GamePhaseProductionAndCardDraw: GamePhase =
  "production_and_card_draw";
export const GamePhaseComplete: GamePhase = "complete";
/**
 * GameStatus represents the current status of the game
 */
export type GameStatus = string;
export const GameStatusLobby: GameStatus = "lobby";
export const GameStatusActive: GameStatus = "active";
export const GameStatusCompleted: GameStatus = "completed";
/**
 * CardType represents different types of cards
 */
export type CardType = string;
export const CardTypeAutomated: CardType = "automated"; // Updated from "effect" to match JSON data
export const CardTypeActive: CardType = "active";
export const CardTypeEvent: CardType = "event";
export const CardTypeCorporation: CardType = "corporation";
export const CardTypePrelude: CardType = "prelude";
/**
 * CardTag represents different card categories and attributes
 */
export type CardTag = string;
export const TagSpace: CardTag = "space";
export const TagEarth: CardTag = "earth";
export const TagScience: CardTag = "science";
export const TagPower: CardTag = "power";
export const TagBuilding: CardTag = "building";
export const TagMicrobe: CardTag = "microbe";
export const TagAnimal: CardTag = "animal";
export const TagPlant: CardTag = "plant";
export const TagEvent: CardTag = "event";
export const TagCity: CardTag = "city";
export const TagVenus: CardTag = "venus";
export const TagJovian: CardTag = "jovian";
export const TagWildlife: CardTag = "wildlife";
export const TagWild: CardTag = "wild";
/**
 * ResourceType represents different types of resources for client consumption
 * This is a 1:1 mapping from model.ResourceType
 */
export type ResourceType = string;
/**
 * Basic resources
 */
export const ResourceTypeCredits: ResourceType = "credits";
export const ResourceTypeSteel: ResourceType = "steel";
export const ResourceTypeTitanium: ResourceType = "titanium";
export const ResourceTypePlants: ResourceType = "plants";
export const ResourceTypeEnergy: ResourceType = "energy";
export const ResourceTypeHeat: ResourceType = "heat";
export const ResourceTypeMicrobes: ResourceType = "microbes";
export const ResourceTypeAnimals: ResourceType = "animals";
export const ResourceTypeFloaters: ResourceType = "floaters";
export const ResourceTypeScience: ResourceType = "science";
export const ResourceTypeAsteroid: ResourceType = "asteroid";
export const ResourceTypeDisease: ResourceType = "disease";
/**
 * Card actions
 */
export const ResourceTypeCardDraw: ResourceType = "card-draw";
export const ResourceTypeCardTake: ResourceType = "card-take";
export const ResourceTypeCardPeek: ResourceType = "card-peek";
/**
 * Terraforming actions
 */
export const ResourceTypeCityPlacement: ResourceType = "city-placement";
export const ResourceTypeOceanPlacement: ResourceType = "ocean-placement";
export const ResourceTypeGreeneryPlacement: ResourceType = "greenery-placement";
/**
 * Tile counting
 */
export const ResourceTypeCityTile: ResourceType = "city-tile";
export const ResourceTypeOceanTile: ResourceType = "ocean-tile";
export const ResourceTypeGreeneryTile: ResourceType = "greenery-tile";
export const ResourceTypeColonyTile: ResourceType = "colony-tile";
/**
 * Global parameters
 */
export const ResourceTypeTemperature: ResourceType = "temperature";
export const ResourceTypeOxygen: ResourceType = "oxygen";
export const ResourceTypeVenus: ResourceType = "venus";
export const ResourceTypeTR: ResourceType = "tr";
/**
 * Production resources
 */
export const ResourceTypeCreditsProduction: ResourceType = "credits-production";
export const ResourceTypeSteelProduction: ResourceType = "steel-production";
export const ResourceTypeTitaniumProduction: ResourceType =
  "titanium-production";
export const ResourceTypePlantsProduction: ResourceType = "plants-production";
export const ResourceTypeEnergyProduction: ResourceType = "energy-production";
export const ResourceTypeHeatProduction: ResourceType = "heat-production";
/**
 * Special effects
 */
export const ResourceTypeEffect: ResourceType = "effect";
export const ResourceTypeTag: ResourceType = "tag";
/**
 * Ongoing effects
 */
export const ResourceTypeGlobalParameterLenience: ResourceType =
  "global-parameter-lenience";
export const ResourceTypeVenusLenience: ResourceType = "venus-lenience";
export const ResourceTypeDefense: ResourceType = "defense";
export const ResourceTypeDiscount: ResourceType = "discount";
export const ResourceTypeValueModifier: ResourceType = "value-modifier";
/**
 * Legacy/deprecated (kept for backwards compatibility)
 */
export const ResourceTypeFighters: ResourceType = "fighters";
export const ResourceTypeCamps: ResourceType = "camps";
export const ResourceTypePreservation: ResourceType = "preservation";
export const ResourceTypeData: ResourceType = "data";
export const ResourceTypeSpecialized: ResourceType = "specialized";
export const ResourceTypeDelegate: ResourceType = "delegate";
export const ResourceTypeInfluence: ResourceType = "influence";
export const ResourceTypeSpecialTile: ResourceType = "special-tile";
export const ResourceTypeTerraformRating: ResourceType = "terraform-rating"; // Use ResourceTypeTR instead
export const ResourceTypeOceans: ResourceType = "oceans";
/**
 * TargetType represents different targeting scopes for resource conditions for client consumption
 */
export type TargetType = string;
export const TargetSelfPlayer: TargetType = "self-player";
export const TargetSelfCard: TargetType = "self-card";
export const TargetAnyCard: TargetType = "any-card";
export const TargetAnyPlayer: TargetType = "any-player";
export const TargetOpponent: TargetType = "opponent";
export const TargetNone: TargetType = "none";
/**
 * CardApplyLocation represents different locations where card conditions can be evaluated for client consumption
 */
export type CardApplyLocation = string;
export const CardApplyLocationAnywhere: CardApplyLocation = "anywhere";
export const CardApplyLocationMars: CardApplyLocation = "mars";
/**
 * TriggerType represents different trigger conditions for client consumption
 */
export type TriggerType = string;
export const TriggerOceanPlaced: TriggerType = "ocean-placed";
export const TriggerTemperatureRaise: TriggerType = "temperature-raise";
export const TriggerOxygenRaise: TriggerType = "oxygen-raise";
export const TriggerCityPlaced: TriggerType = "city-placed";
export const TriggerCardPlayed: TriggerType = "card-played";
export const TriggerTagPlayed: TriggerType = "tag-played";
export const TriggerTilePlaced: TriggerType = "tile-placed";
/**
 * ResourceTriggerType represents different trigger types for resource exchanges for client consumption
 */
export type ResourceTriggerType = string;
export const ResourceTriggerManual: ResourceTriggerType = "manual";
export const ResourceTriggerAuto: ResourceTriggerType = "auto";
/**
 * ResourceSet represents a collection of resources and their amounts
 */
export interface ResourceSet {
  credits: number /* int */;
  steel: number /* int */;
  titanium: number /* int */;
  plants: number /* int */;
  energy: number /* int */;
  heat: number /* int */;
}
/**
 * ResourceConditionDto represents a resource condition for client consumption
 */
export interface ResourceConditionDto {
  type: ResourceType;
  amount: number /* int */;
  target: TargetType;
  affectedResources?: string[];
  affectedTags?: CardTag[];
  affectedStandardProjects?: any /* model.StandardProject */[];
  maxTrigger?: number /* int */;
  per?: PerConditionDto;
}
/**
 * PerConditionDto represents a per condition for client consumption
 */
export interface PerConditionDto {
  type: ResourceType;
  amount: number /* int */;
  location?: CardApplyLocation;
  target?: TargetType;
  tag?: CardTag;
}
/**
 * ChoiceDto represents a choice for client consumption
 */
export interface ChoiceDto {
  inputs?: ResourceConditionDto[];
  outputs?: ResourceConditionDto[];
}
/**
 * TriggerDto represents a trigger for client consumption
 */
export interface TriggerDto {
  type: ResourceTriggerType;
  condition?: ResourceTriggerConditionDto;
}
/**
 * ResourceTriggerConditionDto represents a resource trigger condition for client consumption
 */
export interface ResourceTriggerConditionDto {
  type: TriggerType;
  location?: CardApplyLocation;
  affectedTags?: CardTag[];
  target?: TargetType;
}
/**
 * CardBehaviorDto represents a card behavior for client consumption
 */
export interface CardBehaviorDto {
  triggers?: TriggerDto[];
  inputs?: ResourceConditionDto[];
  outputs?: ResourceConditionDto[];
  choices?: ChoiceDto[];
}
/**
 * ResourceStorageDto represents a card's resource storage capability for client consumption
 */
export interface ResourceStorageDto {
  type: any /* model.ResourceType */;
  capacity?: number /* int */;
  starting: number /* int */;
}
/**
 * CardDto represents a card for client consumption
 */
export interface CardDto {
  id: string;
  name: string;
  type: CardType;
  cost: number /* int */;
  description: string;
  pack: string;
  tags?: CardTag[];
  requirements?: any /* model.Requirement */[];
  behaviors?: CardBehaviorDto[];
  resourceStorage?: ResourceStorageDto;
  vpConditions?: any /* model.VictoryPointCondition */[];
  /**
   * Corporation-specific fields (nil for non-corporation cards)
   */
  startingResources?: ResourceSet; // Parsed from first auto behavior (corporations only)
  startingProduction?: ResourceSet; // Parsed from first auto behavior (corporations only)
}
export interface SelectStartingCardsPhaseDto {
  availableCards: CardDto[]; // Cards available for selection
  availableCorporations: string[]; // Corporation IDs available for selection (2 corporations)
  selectionComplete: boolean; // Whether player completed card selection
}
export interface SelectStartingCardsOtherPlayerDto {
  selectionComplete: boolean; // Whether player completed card selection
}
/**
 * ProductionPhaseDto represents card selection and production phase state for a player
 */
export interface ProductionPhaseDto {
  availableCards: CardDto[]; // Cards available for selection
  selectionComplete: boolean; // Whether player completed card selection
  beforeResources: ResourcesDto;
  afterResources: ResourcesDto;
  resourceDelta: ResourcesDto;
  energyConverted: number /* int */;
  creditsIncome: number /* int */;
}
export interface ProductionPhaseOtherPlayerDto {
  selectionComplete: boolean; // Whether player completed card selection
  beforeResources: ResourcesDto;
  afterResources: ResourcesDto;
  resourceDelta: ResourcesDto;
  energyConverted: number /* int */;
  creditsIncome: number /* int */;
}
/**
 * GameSettingsDto contains configurable game parameters
 */
export interface GameSettingsDto {
  maxPlayers: number /* int */;
  developmentMode: boolean;
  cardPacks?: string[];
}
/**
 * GlobalParametersDto represents the terraforming progress
 */
export interface GlobalParametersDto {
  temperature: number /* int */; // Range: -30 to +8°C
  oxygen: number /* int */; // Range: 0-14%
  oceans: number /* int */; // Range: 0-9
}
/**
 * ResourcesDto represents a player's resources
 */
export interface ResourcesDto {
  credits: number /* int */;
  steel: number /* int */;
  titanium: number /* int */;
  plants: number /* int */;
  energy: number /* int */;
  heat: number /* int */;
}
/**
 * ProductionDto represents a player's production values
 */
export interface ProductionDto {
  credits: number /* int */;
  steel: number /* int */;
  titanium: number /* int */;
  plants: number /* int */;
  energy: number /* int */;
  heat: number /* int */;
}
/**
 * PlayerEffectDto represents ongoing effects that a player has active for client consumption
 * Aligned with PlayerActionDto structure for consistent behavior handling
 */
export interface PlayerEffectDto {
  cardId: string; // ID of the card that provides this effect
  cardName: string; // Name of the card for display purposes
  behaviorIndex: number /* int */; // Which behavior on the card this effect represents
  behavior: CardBehaviorDto; // The actual behavior definition with inputs/outputs
}
/**
 * PlayerActionDto represents an action that a player can take for client consumption
 */
export interface PlayerActionDto {
  cardId: string; // ID of the card that provides this action
  cardName: string; // Name of the card for display purposes
  behaviorIndex: number /* int */; // Which behavior on the card this action represents
  behavior: CardBehaviorDto; // The actual behavior definition with inputs/outputs
  playCount: number /* int */; // Number of times this action has been played this generation
}
/**
 * PendingTileSelectionDto represents a pending tile placement action for client consumption
 * ForcedFirstActionDto represents an action that must be completed as the player's first turn action
 */
export interface ForcedFirstActionDto {
  actionType: string; // Type of action: "city_placement", "card_draw", etc.
  corporationId: string; // Corporation that requires this action
  completed: boolean; // Whether the forced action has been completed
  description: string; // Human-readable description for UI
}
export interface PendingTileSelectionDto {
  tileType: string; // "city", "greenery", "ocean"
  availableHexes: string[]; // Backend-calculated valid hex coordinates
  source: string; // What triggered this selection (card ID, standard project, etc.)
}
/**
 * PendingCardSelectionDto represents a pending card selection action (e.g., sell patents, card effects)
 */
export interface PendingCardSelectionDto {
  availableCards: CardDto[]; // Card IDs player can select from
  cardCosts: { [key: string]: number /* int */ }; // Card ID -> cost to select (0 for sell patents, 3 for buying cards)
  cardRewards: { [key: string]: number /* int */ }; // Card ID -> reward for selecting (1 MC for sell patents)
  source: string; // What triggered this selection ("sell-patents", card ID, etc.)
  minCards: number /* int */; // Minimum cards to select (0 for sell patents)
  maxCards: number /* int */; // Maximum cards to select (hand size for sell patents)
}
/**
 * PendingCardDrawSelectionDto represents a pending card draw/peek/take/buy action from card effects
 */
export interface PendingCardDrawSelectionDto {
  availableCards: CardDto[]; // Cards shown to player (drawn or peeked)
  freeTakeCount: number /* int */; // Number of cards to take for free (mandatory for card-draw, 0 = optional)
  maxBuyCount: number /* int */; // Maximum cards to buy (optional, 0 = no buying allowed)
  cardBuyCost: number /* int */; // Cost per card when buying (typically 3 MC, 0 if no buying)
  source: string; // Card ID or action that triggered this
}
/**
 * PlayerStatus represents the current status of a player in the game
 */
export type PlayerStatus = string;
export const PlayerStatusSelectingStartingCards: PlayerStatus =
  "selecting-starting-cards";
export const PlayerStatusSelectingProductionCards: PlayerStatus =
  "selecting-production-cards";
export const PlayerStatusWaiting: PlayerStatus = "waiting";
export const PlayerStatusActive: PlayerStatus = "active";
/**
 * PlayerDto represents a player in the game for client consumption
 */
export interface PlayerDto {
  id: string;
  name: string;
  status: PlayerStatus;
  corporation?: CardDto;
  cards: CardDto[];
  resources: ResourcesDto;
  production: ProductionDto;
  terraformRating: number /* int */;
  playedCards: string[];
  passed: boolean;
  availableActions: number /* int */;
  victoryPoints: number /* int */;
  isConnected: boolean;
  effects: PlayerEffectDto[]; // Active ongoing effects (discounts, special abilities, etc.)
  actions: PlayerActionDto[]; // Available actions from played cards with manual triggers
  selectStartingCardsPhase?: SelectStartingCardsPhaseDto;
  productionPhase?: ProductionPhaseDto;
  startingCards: CardDto[]; // Cards dealt at game start (from selectStartingCardsPhase.availableCards)
  /**
   * Tile selection - nullable, exists only when player needs to place tiles
   */
  pendingTileSelection?: PendingTileSelectionDto; // Pending tile placement, null when no tiles to place
  /**
   * Card selection - nullable, exists only when player needs to select cards
   */
  pendingCardSelection?: PendingCardSelectionDto; // Pending card selection (sell patents, card effects, etc.)
  /**
   * Card draw/peek/take/buy selection - nullable, exists only when player needs to confirm card draw selection
   */
  pendingCardDrawSelection?: PendingCardDrawSelectionDto; // Pending card draw/peek/take/buy selection from card effects
  /**
   * Forced first action - nullable, exists only when corporation requires specific first turn action
   */
  forcedFirstAction?: ForcedFirstActionDto; // Action that must be taken on first turn (Tharsis city placement, etc.)
  /**
   * Resource storage - maps card IDs to resource counts stored on those cards
   */
  resourceStorage: { [key: string]: number /* int */ }; // Card ID -> resource count
}
/**
 * OtherPlayerDto represents another player from the viewing player's perspective (limited data)
 */
export interface OtherPlayerDto {
  id: string;
  name: string;
  status: PlayerStatus;
  corporation?: CardDto;
  handCardCount: number /* int */; // Number of cards in hand (private)
  resources: ResourcesDto;
  production: ProductionDto;
  terraformRating: number /* int */;
  playedCards: string[]; // Played cards are public
  passed: boolean;
  availableActions: number /* int */;
  victoryPoints: number /* int */;
  isConnected: boolean;
  effects: PlayerEffectDto[];
  actions: PlayerActionDto[];
  selectStartingCardsPhase?: SelectStartingCardsOtherPlayerDto;
  productionPhase?: ProductionPhaseOtherPlayerDto;
  /**
   * Resource storage - maps card IDs to resource counts stored on those cards (public information)
   */
  resourceStorage: { [key: string]: number /* int */ }; // Card ID -> resource count
}
/**
 * GameDto represents a game for client consumption (clean architecture)
 */
export interface GameDto {
  id: string;
  status: GameStatus;
  settings: GameSettingsDto;
  hostPlayerId: string;
  currentPhase: GamePhase;
  globalParameters: GlobalParametersDto;
  currentPlayer: PlayerDto; // Viewing player's full data
  otherPlayers: OtherPlayerDto[]; // Other players' limited data
  viewingPlayerId: string; // The player viewing this game state
  currentTurn?: string; // Whose turn it is (nullable)
  generation: number /* int */;
  turnOrder: string[]; // Turn order of all players in game
  board: BoardDto; // Game board with tiles and occupancy state
  paymentConstants: PaymentConstantsDto; // Conversion rates for alternative payments
}
/**
 * TileBonusDto represents a resource bonus provided by a tile when occupied
 */
export interface TileBonusDto {
  /**
   * Type specifies the resource type granted by this bonus
   */
  type: string;
  /**
   * Amount specifies the quantity of the bonus granted
   */
  amount: number /* int */;
}
/**
 * TileOccupantDto represents what currently occupies a tile
 */
export interface TileOccupantDto {
  /**
   * Type specifies the type of occupant (city-tile, ocean-tile, greenery-tile, etc.)
   */
  type: string;
  /**
   * Tags specifies special properties of the occupant (e.g., "capital" for cities)
   */
  tags: string[];
}
/**
 * TileDto represents a single hexagonal tile on the game board
 */
export interface TileDto {
  /**
   * Coordinates specifies the hex position of this tile
   */
  coordinates: HexPositionDto;
  /**
   * Tags specifies special properties for placement restrictions (e.g., "noctis-city")
   */
  tags: string[];
  /**
   * Type specifies the base type of tile (ocean-tile for ocean spaces, etc.)
   */
  type: string;
  /**
   * Location specifies which celestial body this tile is on
   */
  location: string;
  /**
   * DisplayName specifies the optional display name shown on the tile
   */
  displayName?: string;
  /**
   * Bonuses specifies the resource bonuses provided by this tile
   */
  bonuses: TileBonusDto[];
  /**
   * OccupiedBy specifies what currently occupies this tile, if anything
   */
  occupiedBy?: TileOccupantDto;
  /**
   * OwnerID specifies the player who owns this tile, if any
   */
  ownerId?: string;
}
/**
 * BoardDto represents the game board containing all tiles
 */
export interface BoardDto {
  /**
   * Tiles specifies all tiles on the game board
   */
  tiles: TileDto[];
}

//////////
// source: http_dto.go

/**
 * CreateGameRequest represents the request body for creating a game
 */
export interface CreateGameRequest {
  maxPlayers: number /* int */;
  developmentMode: boolean;
}
/**
 * CreateGameResponse represents the response for creating a game
 */
export interface CreateGameResponse {
  game: GameDto;
}
/**
 * JoinGameRequest represents the request body for joining a game
 */
export interface JoinGameRequest {
  playerName: string;
}
/**
 * JoinGameResponse represents the response for joining a game
 */
export interface JoinGameResponse {
  game: GameDto;
  playerId: string;
}
/**
 * GetGameResponse represents the response for getting a game
 */
export interface GetGameResponse {
  game: GameDto;
}
/**
 * ListGamesResponse represents the response for listing games
 */
export interface ListGamesResponse {
  games: GameDto[];
}
/**
 * GetPlayerResponse represents the response for getting a player
 */
export interface GetPlayerResponse {
  player: PlayerDto;
}
/**
 * ListCardsResponse represents the response for listing cards with pagination
 */
export interface ListCardsResponse {
  cards: CardDto[];
  totalCount: number /* int */;
  offset: number /* int */;
  limit: number /* int */;
}
/**
 * ErrorResponse represents an error response
 */
export interface ErrorResponse {
  error: string;
  code?: string;
  details?: string;
}

//////////
// source: message_types.go

/**
 * MessageType represents different types of WebSocket messages
 */
export type MessageType = string;
/**
 * Existing Client -> Server messages
 */
export const MessageTypePlayerConnect: MessageType = "player-connect";
/**
 * Existing Server -> Client messages
 */
export const MessageTypeGameUpdated: MessageType = "game-updated";
export const MessageTypePlayerConnected: MessageType = "player-connected";
export const MessageTypePlayerReconnected: MessageType = "player-reconnected";
export const MessageTypePlayerDisconnected: MessageType = "player-disconnected";
export const MessageTypeError: MessageType = "error";
export const MessageTypeFullState: MessageType = "full-state";
export const MessageTypeProductionPhaseStarted: MessageType =
  "production-phase-started";
/**
 * Standard project message types
 */
export const MessageTypeActionSellPatents: MessageType =
  "action.standard-project.sell-patents";
export const MessageTypeActionLaunchAsteroid: MessageType =
  "action.standard-project.launch-asteroid";
export const MessageTypeActionBuildPowerPlant: MessageType =
  "action.standard-project.build-power-plant";
export const MessageTypeActionBuildAquifer: MessageType =
  "action.standard-project.build-aquifer";
export const MessageTypeActionPlantGreenery: MessageType =
  "action.standard-project.plant-greenery";
export const MessageTypeActionBuildCity: MessageType =
  "action.standard-project.build-city";
/**
 * Game management message types
 */
export const MessageTypeActionStartGame: MessageType =
  "action.game-management.start-game";
export const MessageTypeActionSkipAction: MessageType =
  "action.game-management.skip-action";
/**
 * Tile selection message types
 */
export const MessageTypeActionTileSelected: MessageType =
  "action.tile-selection.tile-selected";
/**
 * Card message types
 */
export const MessageTypeActionPlayCard: MessageType = "action.card.play-card";
export const MessageTypeActionCardAction: MessageType =
  "action.card.card-action";
export const MessageTypeActionSelectStartingCard: MessageType =
  "action.card.select-starting-card";
export const MessageTypeActionSelectCards: MessageType =
  "action.card.select-cards";
export const MessageTypeActionCardDrawConfirmed: MessageType =
  "action.card.card-draw-confirmed";
/**
 * Admin message types (development mode only)
 */
export const MessageTypeAdminCommand: MessageType = "admin-command";

//////////
// source: payment_constants_dto.go

/**
 * PaymentConstantsDto contains the conversion rates for alternative payment methods
 * These values are sent to the frontend so it knows how much each resource is worth
 */
export interface PaymentConstantsDto {
  steelValue: number /* int */; // How many MC each steel is worth (2)
  titaniumValue: number /* int */; // How many MC each titanium is worth (3)
}

//////////
// source: websocket_dto.go

/**
 * WebSocketMessage represents a WebSocket message
 */
export interface WebSocketMessage {
  type: MessageType;
  payload: any;
  gameId?: string;
}
/**
 * PlayerConnectPayload contains player connection data
 */
export interface PlayerConnectPayload {
  playerName: string;
  gameId: string;
  playerId?: string; // Optional: used for reconnection
}
/**
 * GameUpdatedPayload contains updated game state
 */
export interface GameUpdatedPayload {
  game: GameDto;
}
/**
 * PlayerConnectedPayload contains data about a newly connected player
 */
export interface PlayerConnectedPayload {
  playerId: string;
  playerName: string;
  game: GameDto;
}
/**
 * ErrorPayload contains error information
 */
export interface ErrorPayload {
  message: string;
  code?: string;
}
/**
 * FullStatePayload contains the complete game state
 */
export interface FullStatePayload {
  game: GameDto;
  playerId: string;
}
/**
 * PlayerReconnectedPayload contains data about a reconnected player
 */
export interface PlayerReconnectedPayload {
  playerId: string;
  playerName: string;
  game: GameDto;
}
/**
 * PlayerDisconnectedPayload contains data about a disconnected player (for internal handler use)
 */
export interface PlayerDisconnectedPayload {
  playerId: string;
  gameId: string;
}
/**
 * PlayerProductionData contains production data for a single player
 */
export interface PlayerProductionData {
  playerId: string;
  playerName: string;
  production: ProductionDto;
}
/**
 * ProductionPhaseStartedPayload contains data when production phase begins
 */
export interface ProductionPhaseStartedPayload {
  generation: number /* int */;
  playersData: PlayerProductionData[];
  game: GameDto;
}
/**
 * ConfirmStartingCardSelectionMessage represents confirm starting card selection message
 */
export interface ConfirmStartingCardSelectionMessage {
  gameId: string;
  playerId: string;
}
