// Code generated by tygo. DO NOT EDIT.

//////////
// source: actions_dto.go

/**
 * ActionType represents different types of game actions
 */
export type ActionType = string;
export const ActionTypeSelectStartingCard: ActionType = "select-starting-card";
export const ActionTypeSelectCards: ActionType = "select-cards";
export const ActionTypeStartGame: ActionType = "start-game";
export const ActionTypeSkipAction: ActionType = "skip-action";
export const ActionTypePlayCard: ActionType = "play-card";
export const ActionTypeCardAction: ActionType = "card-action";
export const ActionTypeSellPatents: ActionType = "sell-patents";
export const ActionTypeBuildPowerPlant: ActionType = "build-power-plant";
export const ActionTypeLaunchAsteroid: ActionType = "launch-asteroid";
export const ActionTypeBuildAquifer: ActionType = "build-aquifer";
export const ActionTypePlantGreenery: ActionType = "plant-greenery";
export const ActionTypeBuildCity: ActionType = "build-city";
export const ActionTypeConvertPlantsToGreenery: ActionType = "convert-plants-to-greenery";
export const ActionTypeConvertHeatToTemperature: ActionType = "convert-heat-to-temperature";
/**
 * SelectStartingCardAction represents selecting starting cards and corporation
 */
export interface SelectStartingCardAction {
  type: ActionType;
  cardIds: string[];
  corporationId: string;
}
/**
 * StartGameAction represents starting the game (host only)
 */
export interface StartGameAction {
  type: ActionType;
}
/**
 * SkipAction represents skipping a player's turn
 */
export interface SkipAction {
  type: ActionType;
}
/**
 * PlayCardAction represents playing a card from hand
 */
export interface PlayCardAction {
  cardId: string;
  payment: CardPaymentDto; // Required: payment breakdown (credits, steel, titanium)
  choiceIndex?: number /* int */; // Optional: index of choice to play (for cards with choices)
  cardStorageTarget?: string; // Optional: target card ID for resource storage (for outputs with target "any-card")
}
/**
 * PlayCardActionAction represents playing a card action from player's action list
 */
export interface PlayCardActionAction {
  cardId: string;
  behaviorIndex: number /* int */;
  choiceIndex?: number /* int */; // Optional: index of choice to play (for actions with choices)
  cardStorageTarget?: string; // Optional: target card ID for resource storage (for outputs with target "any-card")
}
/**
 * HexPositionDto represents a position on the Mars board
 */
export interface HexPositionDto {
  q: number /* int */;
  r: number /* int */;
  s: number /* int */;
}
/**
 * SellPatentsAction represents selling patent cards for megacredits (initiates card selection)
 */
export interface SellPatentsAction {
  type: ActionType;
}
/**
 * BuildPowerPlantAction represents building a power plant
 */
export interface BuildPowerPlantAction {
  type: ActionType;
}
/**
 * LaunchAsteroidAction represents launching an asteroid
 */
export interface LaunchAsteroidAction {
  type: ActionType;
}
/**
 * BuildAquiferAction represents building an aquifer
 */
export interface BuildAquiferAction {
  type: ActionType;
  hexPosition: HexPositionDto;
}
/**
 * PlantGreeneryAction represents planting greenery
 */
export interface PlantGreeneryAction {
  type: ActionType;
  hexPosition: HexPositionDto;
}
/**
 * BuildCityAction represents building a city
 */
export interface BuildCityAction {
  type: ActionType;
  hexPosition: HexPositionDto;
}
/**
 * ActionSelectStartingCardRequest contains the action data for select starting card actions
 */
export interface ActionSelectStartingCardRequest {
  type: ActionType;
  cardIds: string[];
  corporationId: string; // Corporation selected alongside starting cards
}
/**
 * ActionSelectProductionCardsRequest contains the action data for select production card actions
 */
export interface ActionSelectProductionCardsRequest {
  type: ActionType;
  cardIds: string[];
}
/**
 * ActionStartGameRequest contains the action data for start game actions
 */
export interface ActionStartGameRequest {
  type: ActionType;
}
/**
 * ActionSkipActionRequest contains the action data for skip action actions
 */
export interface ActionSkipActionRequest {
  type: ActionType;
}
/**
 * ConfirmDemoSetupRequest contains the player's demo setup configuration
 */
export interface ConfirmDemoSetupRequest {
  corporationId?: string;
  cardIds: string[];
  resources: ResourcesDto;
  production: ProductionDto;
  terraformRating: number /* int */;
  globalParameters?: GlobalParametersDto; // Host only
  generation?: number /* int */; // Host only
}
/**
 * ActionPlayCardRequest contains the action data for play card actions
 */
export interface ActionPlayCardRequest {
  type: ActionType;
  cardId: string;
  payment: CardPaymentDto; // Required: payment breakdown (credits, steel, titanium)
  choiceIndex?: number /* int */; // Optional: index of choice to play (for cards with choices)
  cardStorageTarget?: string; // Optional: target card ID for resource storage (for outputs with target "any-card")
}
/**
 * ActionPlayCardActionRequest contains the action data for play card action actions
 */
export interface ActionPlayCardActionRequest {
  type: ActionType;
  cardId: string;
  behaviorIndex: number /* int */;
  choiceIndex?: number /* int */; // Optional: index of choice to play (for actions with choices)
  cardStorageTarget?: string; // Optional: target card ID for resource storage (for outputs with target "any-card")
}
/**
 * ActionSellPatentsRequest contains the action data for sell patents actions (initiates card selection)
 */
export interface ActionSellPatentsRequest {
  type: ActionType;
}
/**
 * ActionBuildPowerPlantRequest contains the action data for build power plant actions
 */
export interface ActionBuildPowerPlantRequest {
  type: ActionType;
}
/**
 * ActionLaunchAsteroidRequest contains the action data for launch asteroid actions
 */
export interface ActionLaunchAsteroidRequest {
  type: ActionType;
}
/**
 * ActionBuildAquiferRequest contains the action data for build aquifer actions
 */
export interface ActionBuildAquiferRequest {
  type: ActionType;
  hexPosition: HexPositionDto;
}
/**
 * ActionPlantGreeneryRequest contains the action data for plant greenery actions
 */
export interface ActionPlantGreeneryRequest {
  type: ActionType;
  hexPosition: HexPositionDto;
}
/**
 * ActionBuildCityRequest contains the action data for build city actions
 */
export interface ActionBuildCityRequest {
  type: ActionType;
  hexPosition: HexPositionDto;
}
/**
 * ActionConvertPlantsToGreeneryRequest contains the action data for initiating plant conversion
 */
export interface ActionConvertPlantsToGreeneryRequest {
  type: ActionType;
}
/**
 * ActionConvertHeatToTemperatureRequest contains the action data for converting heat to temperature
 */
export interface ActionConvertHeatToTemperatureRequest {
  type: ActionType;
}
/**
 * ConvertPlantsToGreeneryAction represents converting 8 plants to a greenery tile
 */
export interface ConvertPlantsToGreeneryAction {
  type: ActionType;
}
/**
 * ConvertHeatToTemperatureAction represents converting 8 heat to raise temperature
 */
export interface ConvertHeatToTemperatureAction {
  type: ActionType;
}
/**
 * AdminCommandType represents different types of admin commands
 */
export type AdminCommandType = string;
export const AdminCommandTypeGiveCard: AdminCommandType = "give-card";
export const AdminCommandTypeSetPhase: AdminCommandType = "set-phase";
export const AdminCommandTypeSetResources: AdminCommandType = "set-resources";
export const AdminCommandTypeSetProduction: AdminCommandType = "set-production";
export const AdminCommandTypeSetGlobalParams: AdminCommandType = "set-global-params";
export const AdminCommandTypeStartTileSelection: AdminCommandType = "start-tile-selection";
export const AdminCommandTypeSetCurrentTurn: AdminCommandType = "set-current-turn";
export const AdminCommandTypeSetCorporation: AdminCommandType = "set-corporation";
export const AdminCommandTypeSetTR: AdminCommandType = "set-tr";
/**
 * AdminCommandRequest contains the admin command data
 */
export interface AdminCommandRequest {
  commandType: AdminCommandType;
  payload: any;
}
/**
 * GiveCardAdminCommand represents giving a card to a player
 */
export interface GiveCardAdminCommand {
  playerId: string;
  cardId: string;
}
/**
 * SetPhaseAdminCommand represents setting the game phase
 */
export interface SetPhaseAdminCommand {
  phase: string;
}
/**
 * SetResourcesAdminCommand represents setting a player's resources
 */
export interface SetResourcesAdminCommand {
  playerId: string;
  resources: ResourcesDto;
}
/**
 * SetProductionAdminCommand represents setting a player's production
 */
export interface SetProductionAdminCommand {
  playerId: string;
  production: ProductionDto;
}
/**
 * SetGlobalParamsAdminCommand represents setting global parameters
 */
export interface SetGlobalParamsAdminCommand {
  globalParameters: GlobalParametersDto;
}
/**
 * StartTileSelectionAdminCommand represents starting tile selection for testing
 */
export interface StartTileSelectionAdminCommand {
  playerId: string;
  tileType: string;
}
/**
 * SetCorporationAdminCommand represents setting a player's corporation
 */
export interface SetCorporationAdminCommand {
  playerId: string;
  corporationId: string;
}
/**
 * SetTRAdminCommand represents setting a player's terraform rating
 */
export interface SetTRAdminCommand {
  playerId: string;
  terraformRating: number /* int */;
}
/**
 * CardPaymentDto represents how a player is paying for a card
 */
export interface CardPaymentDto {
  credits: number /* int */; // MC spent
  steel: number /* int */; // Steel resources used (2 MC value each)
  titanium: number /* int */; // Titanium resources used (3 MC value each)
  substitutes?: { [key: string]: number /* int */ }; // Payment substitutes (e.g., heat for Helion)
}

//////////
// source: game_dto.go

/**
 * GamePhase represents the current phase of the game
 */
export type GamePhase = string;
export const GamePhaseWaitingForGameStart: GamePhase = "waiting_for_game_start";
export const GamePhaseStartingCardSelection: GamePhase = "starting_card_selection";
export const GamePhaseStartGameSelection: GamePhase = "start_game_selection";
export const GamePhaseDemoSetup: GamePhase = "demo_setup";
export const GamePhaseAction: GamePhase = "action";
export const GamePhaseProductionAndCardDraw: GamePhase = "production_and_card_draw";
export const GamePhaseComplete: GamePhase = "complete";
/**
 * GameStatus represents the current status of the game
 */
export type GameStatus = string;
export const GameStatusLobby: GameStatus = "lobby";
export const GameStatusActive: GameStatus = "active";
export const GameStatusCompleted: GameStatus = "completed";
/**
 * CardType represents different types of cards
 */
export type CardType = string;
export const CardTypeAutomated: CardType = "automated";
export const CardTypeActive: CardType = "active";
export const CardTypeEvent: CardType = "event";
export const CardTypeCorporation: CardType = "corporation";
export const CardTypePrelude: CardType = "prelude";
/**
 * StandardProject represents the different types of standard projects
 */
export type StandardProject = string;
export const StandardProjectSellPatents: StandardProject = "sell-patents";
export const StandardProjectPowerPlant: StandardProject = "power-plant";
export const StandardProjectAsteroid: StandardProject = "asteroid";
export const StandardProjectAquifer: StandardProject = "aquifer";
export const StandardProjectGreenery: StandardProject = "greenery";
export const StandardProjectCity: StandardProject = "city";
export const StandardProjectConvertPlantsToGreenery: StandardProject = "convert-plants-to-greenery";
export const StandardProjectConvertHeatToTemperature: StandardProject =
  "convert-heat-to-temperature";
/**
 * CardTag represents different card categories and attributes
 */
export type CardTag = string;
export const TagSpace: CardTag = "space";
export const TagEarth: CardTag = "earth";
export const TagScience: CardTag = "science";
export const TagPower: CardTag = "power";
export const TagBuilding: CardTag = "building";
export const TagMicrobe: CardTag = "microbe";
export const TagAnimal: CardTag = "animal";
export const TagPlant: CardTag = "plant";
export const TagEvent: CardTag = "event";
export const TagCity: CardTag = "city";
export const TagVenus: CardTag = "venus";
export const TagJovian: CardTag = "jovian";
export const TagWildlife: CardTag = "wildlife";
export const TagWild: CardTag = "wild";
/**
 * ResourceType represents different types of resources for client consumption
 * This is a 1:1 mapping from types.ResourceType
 */
export type ResourceType = string;
export const ResourceTypeCredit: ResourceType = "credit";
export const ResourceTypeSteel: ResourceType = "steel";
export const ResourceTypeTitanium: ResourceType = "titanium";
export const ResourceTypePlant: ResourceType = "plant";
export const ResourceTypeEnergy: ResourceType = "energy";
export const ResourceTypeHeat: ResourceType = "heat";
export const ResourceTypeMicrobe: ResourceType = "microbe";
export const ResourceTypeAnimal: ResourceType = "animal";
export const ResourceTypeFloater: ResourceType = "floater";
export const ResourceTypeScience: ResourceType = "science";
export const ResourceTypeAsteroid: ResourceType = "asteroid";
export const ResourceTypeDisease: ResourceType = "disease";
export const ResourceTypeCardDraw: ResourceType = "card-draw";
export const ResourceTypeCardTake: ResourceType = "card-take";
export const ResourceTypeCardPeek: ResourceType = "card-peek";
export const ResourceTypeCityPlacement: ResourceType = "city-placement";
export const ResourceTypeOceanPlacement: ResourceType = "ocean-placement";
export const ResourceTypeGreeneryPlacement: ResourceType = "greenery-placement";
export const ResourceTypeCityTile: ResourceType = "city-tile";
export const ResourceTypeOceanTile: ResourceType = "ocean-tile";
export const ResourceTypeGreeneryTile: ResourceType = "greenery-tile";
export const ResourceTypeColonyTile: ResourceType = "colony-tile";
export const ResourceTypeTemperature: ResourceType = "temperature";
export const ResourceTypeOxygen: ResourceType = "oxygen";
export const ResourceTypeVenus: ResourceType = "venus";
export const ResourceTypeTR: ResourceType = "tr";
export const ResourceTypeCreditProduction: ResourceType = "credit-production";
export const ResourceTypeSteelProduction: ResourceType = "steel-production";
export const ResourceTypeTitaniumProduction: ResourceType = "titanium-production";
export const ResourceTypePlantProduction: ResourceType = "plant-production";
export const ResourceTypeEnergyProduction: ResourceType = "energy-production";
export const ResourceTypeHeatProduction: ResourceType = "heat-production";
export const ResourceTypeEffect: ResourceType = "effect";
export const ResourceTypeTag: ResourceType = "tag";
export const ResourceTypeGlobalParameterLenience: ResourceType = "global-parameter-lenience";
export const ResourceTypeVenusLenience: ResourceType = "venus-lenience";
export const ResourceTypeDefense: ResourceType = "defense";
export const ResourceTypeDiscount: ResourceType = "discount";
export const ResourceTypeValueModifier: ResourceType = "value-modifier";
/**
 * TargetType represents different targeting scopes for resource conditions for client consumption
 */
export type TargetType = string;
export const TargetSelfPlayer: TargetType = "self-player";
export const TargetSelfCard: TargetType = "self-card";
export const TargetAnyCard: TargetType = "any-card";
export const TargetAnyPlayer: TargetType = "any-player";
export const TargetOpponent: TargetType = "opponent";
export const TargetNone: TargetType = "none";
/**
 * CardApplyLocation represents different locations where card conditions can be evaluated for client consumption
 */
export type CardApplyLocation = string;
export const CardApplyLocationAnywhere: CardApplyLocation = "anywhere";
export const CardApplyLocationMars: CardApplyLocation = "mars";
/**
 * RequirementType represents different card requirement types for client consumption
 */
export type RequirementType = string;
export const RequirementTemperature: RequirementType = "temperature";
export const RequirementOxygen: RequirementType = "oxygen";
export const RequirementOceans: RequirementType = "oceans";
export const RequirementVenus: RequirementType = "venus";
export const RequirementCities: RequirementType = "cities";
export const RequirementGreeneries: RequirementType = "greeneries";
export const RequirementTags: RequirementType = "tags";
export const RequirementProduction: RequirementType = "production";
export const RequirementTR: RequirementType = "tr";
export const RequirementResource: RequirementType = "resource";
/**
 * VPConditionType represents different types of VP conditions for client consumption
 */
export type VPConditionType = string;
export const VPConditionFixed: VPConditionType = "fixed";
export const VPConditionPer: VPConditionType = "per";
export const VPConditionResourcesOn: VPConditionType = "resources-on";
/**
 * TriggerType represents different trigger conditions for client consumption
 */
export type TriggerType = string;
export const TriggerOceanPlaced: TriggerType = "ocean-placed";
export const TriggerTemperatureRaise: TriggerType = "temperature-raise";
export const TriggerOxygenRaise: TriggerType = "oxygen-raise";
export const TriggerCityPlaced: TriggerType = "city-placed";
export const TriggerCardPlayed: TriggerType = "card-played";
export const TriggerTagPlayed: TriggerType = "tag-played";
export const TriggerTilePlaced: TriggerType = "tile-placed";
/**
 * ResourceTriggerType represents different trigger types for resource exchanges for client consumption
 */
export type ResourceTriggerType = string;
export const ResourceTriggerManual: ResourceTriggerType = "manual";
export const ResourceTriggerAuto: ResourceTriggerType = "auto";
export const ResourceTriggerAutoCorporationFirstAction: ResourceTriggerType =
  "auto-corporation-first-action";
export const ResourceTriggerAutoCorporationStart: ResourceTriggerType = "auto-corporation-start";
/**
 * ResourceSet represents a collection of resources and their amounts
 */
export interface ResourceSet {
  credits: number /* int */;
  steel: number /* int */;
  titanium: number /* int */;
  plants: number /* int */;
  energy: number /* int */;
  heat: number /* int */;
}
/**
 * ResourceConditionDto represents a resource condition for client consumption
 */
export interface ResourceConditionDto {
  type: ResourceType;
  amount: number /* int */;
  target: TargetType;
  affectedResources?: string[];
  affectedTags?: CardTag[];
  affectedCardTypes?: CardType[];
  affectedStandardProjects?: StandardProject[];
  maxTrigger?: number /* int */;
  per?: PerConditionDto;
}
/**
 * PerConditionDto represents a per condition for client consumption
 */
export interface PerConditionDto {
  type: ResourceType;
  amount: number /* int */;
  location?: CardApplyLocation;
  target?: TargetType;
  tag?: CardTag;
}
/**
 * ChoiceDto represents a choice for client consumption
 */
export interface ChoiceDto {
  inputs?: ResourceConditionDto[];
  outputs?: ResourceConditionDto[];
}
/**
 * TriggerDto represents a trigger for client consumption
 */
export interface TriggerDto {
  type: ResourceTriggerType;
  condition?: ResourceTriggerConditionDto;
}
/**
 * MinMaxValueDto represents a minimum and/or maximum value constraint for client consumption
 */
export interface MinMaxValueDto {
  min?: number /* int */;
  max?: number /* int */;
}
/**
 * ResourceTriggerConditionDto represents a resource trigger condition for client consumption
 */
export interface ResourceTriggerConditionDto {
  type: TriggerType;
  location?: CardApplyLocation;
  affectedTags?: CardTag[];
  affectedResources?: string[]; // Resource types that trigger this effect (for placement-bonus-gained)
  affectedCardTypes?: CardType[]; // Card types that trigger this effect (for card-played)
  target?: TargetType;
  requiredOriginalCost?: MinMaxValueDto;
  requiredResourceChange?: { [key: ResourceType]: MinMaxValueDto };
}
/**
 * CardBehaviorDto represents a card behavior for client consumption
 */
export interface CardBehaviorDto {
  description?: string;
  triggers?: TriggerDto[];
  inputs?: ResourceConditionDto[];
  outputs?: ResourceConditionDto[];
  choices?: ChoiceDto[];
  generationalEventRequirements?: GenerationalEventRequirementDto[];
}
/**
 * PaymentConstantsDto represents payment conversion rates
 */
export interface PaymentConstantsDto {
  steelValue: number /* int */;
  titaniumValue: number /* int */;
}
/**
 * RequirementDto represents a card requirement for client consumption
 */
export interface RequirementDto {
  type: RequirementType;
  min?: number /* int */;
  max?: number /* int */;
  location?: CardApplyLocation;
  tag?: CardTag;
  resource?: ResourceType;
}
/**
 * ResourceStorageDto represents a card's resource storage for client consumption
 */
export interface ResourceStorageDto {
  type: ResourceType;
  capacity?: number /* int */;
  starting: number /* int */;
}
/**
 * VPConditionDto represents a victory point condition for client consumption
 */
export interface VPConditionDto {
  amount: number /* int */;
  condition: VPConditionType;
  maxTrigger?: number /* int */;
  per?: PerConditionDto;
}
/**
 * CardDto represents a card for client consumption
 */
export interface CardDto {
  id: string;
  name: string;
  type: CardType;
  cost: number /* int */;
  description: string;
  pack: string;
  tags?: CardTag[];
  requirements?: RequirementDto[];
  behaviors?: CardBehaviorDto[];
  resourceStorage?: ResourceStorageDto;
  vpConditions?: VPConditionDto[];
  startingResources?: ResourceSet;
  startingProduction?: ResourceSet;
}
export interface SelectStartingCardsPhaseDto {
  availableCards: CardDto[]; // Cards available for selection
  availableCorporations: CardDto[]; // Corporation cards available for selection (2 corporations)
}
export interface SelectStartingCardsOtherPlayerDto {}
/**
 * ProductionPhaseDto represents card selection and production phase state for a player
 */
export interface ProductionPhaseDto {
  availableCards: CardDto[]; // Cards available for selection
  selectionComplete: boolean; // Whether player completed card selection
  beforeResources: ResourcesDto;
  afterResources: ResourcesDto;
  resourceDelta: ResourcesDto;
  energyConverted: number /* int */;
  creditsIncome: number /* int */;
}
export interface ProductionPhaseOtherPlayerDto {
  selectionComplete: boolean; // Whether player completed card selection
  beforeResources: ResourcesDto;
  afterResources: ResourcesDto;
  resourceDelta: ResourcesDto;
  energyConverted: number /* int */;
  creditsIncome: number /* int */;
}
/**
 * GameSettingsDto contains configurable game parameters
 */
export interface GameSettingsDto {
  maxPlayers: number /* int */;
  developmentMode: boolean;
  demoGame: boolean;
  cardPacks?: string[];
}
/**
 * GlobalParametersDto represents the terraforming progress
 */
export interface GlobalParametersDto {
  temperature: number /* int */; // Range: -30 to +8Â°C
  oxygen: number /* int */; // Range: 0-14%
  oceans: number /* int */; // Range: 0-9
}
/**
 * ResourcesDto represents a player's resources
 */
export interface ResourcesDto {
  credits: number /* int */;
  steel: number /* int */;
  titanium: number /* int */;
  plants: number /* int */;
  energy: number /* int */;
  heat: number /* int */;
}
/**
 * ProductionDto represents a player's production values
 */
export interface ProductionDto {
  credits: number /* int */;
  steel: number /* int */;
  titanium: number /* int */;
  plants: number /* int */;
  energy: number /* int */;
  heat: number /* int */;
}
/**
 * PaymentSubstituteDto represents an alternative resource that can be used as payment for credits
 */
export interface PaymentSubstituteDto {
  resourceType: ResourceType;
  conversionRate: number /* int */;
}
/**
 * StateErrorCode represents error codes for entity state validation.
 * All codes use kebab-case for consistency with JSON serialization.
 */
export type StateErrorCode = string;
export const ErrorCodeNotYourTurn: StateErrorCode = "not-your-turn";
export const ErrorCodeWrongPhase: StateErrorCode = "wrong-phase";
export const ErrorCodeInsufficientCredits: StateErrorCode = "insufficient-credits";
export const ErrorCodeInsufficientResources: StateErrorCode = "insufficient-resources";
export const ErrorCodeTooManyResources: StateErrorCode = "too-many-resources";
export const ErrorCodeTemperatureTooLow: StateErrorCode = "temperature-too-low";
export const ErrorCodeTemperatureTooHigh: StateErrorCode = "temperature-too-high";
export const ErrorCodeOxygenTooLow: StateErrorCode = "oxygen-too-low";
export const ErrorCodeOxygenTooHigh: StateErrorCode = "oxygen-too-high";
export const ErrorCodeOceansTooLow: StateErrorCode = "oceans-too-low";
export const ErrorCodeOceansTooHigh: StateErrorCode = "oceans-too-high";
export const ErrorCodeTRTooLow: StateErrorCode = "tr-too-low";
export const ErrorCodeTRTooHigh: StateErrorCode = "tr-too-high";
export const ErrorCodeInsufficientTags: StateErrorCode = "insufficient-tags";
export const ErrorCodeTooManyTags: StateErrorCode = "too-many-tags";
export const ErrorCodeInsufficientProduction: StateErrorCode = "insufficient-production";
export const ErrorCodeNoOceanTiles: StateErrorCode = "no-ocean-tiles";
export const ErrorCodeNoCityPlacements: StateErrorCode = "no-city-placements";
export const ErrorCodeNoGreeneryPlacements: StateErrorCode = "no-greenery-placements";
export const ErrorCodeNoCardsInHand: StateErrorCode = "no-cards-in-hand";
export const ErrorCodeInvalidProjectType: StateErrorCode = "invalid-project-type";
export const ErrorCodeInvalidRequirement: StateErrorCode = "invalid-requirement";
export const ErrorCodeInvalidCardType: StateErrorCode = "invalid-card-type";
/**
 * StateErrorCategory represents categories for error grouping.
 * Categories enable UI filtering and display organization.
 */
export type StateErrorCategory = string;
export const ErrorCategoryTurn: StateErrorCategory = "turn";
export const ErrorCategoryPhase: StateErrorCategory = "phase";
export const ErrorCategoryCost: StateErrorCategory = "cost";
export const ErrorCategoryInput: StateErrorCategory = "input";
export const ErrorCategoryRequirement: StateErrorCategory = "requirement";
export const ErrorCategoryAvailability: StateErrorCategory = "availability";
export const ErrorCategoryConfiguration: StateErrorCategory = "configuration";
export const ErrorCategoryInternal: StateErrorCategory = "internal";
/**
 * StateErrorDto represents a specific reason why an entity (card, action, project) is unavailable
 * Part of the Player-Scoped Card Architecture for rich error information
 */
export interface StateErrorDto {
  code: StateErrorCode; // Error code (e.g., ErrorCodeInsufficientCredits)
  category: StateErrorCategory; // Error category (e.g., ErrorCategoryCost)
  message: string; // Human-readable error message
}
/**
 * PlayerCardDto represents a card in a player's hand with calculated playability state
 * Part of the Player-Scoped Card Architecture
 */
export interface PlayerCardDto {
  id: string;
  name: string;
  type: CardType;
  cost: number /* int */; // Original card cost (same as CardDto.Cost)
  description: string;
  pack: string;
  tags?: CardTag[];
  requirements?: RequirementDto[];
  behaviors?: CardBehaviorDto[];
  resourceStorage?: ResourceStorageDto;
  vpConditions?: VPConditionDto[];
  available: boolean; // Computed: len(Errors) == 0
  errors: StateErrorDto[]; // Single source of truth for availability
  effectiveCost: number /* int */; // Effective cost after discounts (credits)
  discounts?: { [key: string]: number /* int */ }; // Discount amounts per resource type (if any)
}
/**
 * PlayerEffectDto represents ongoing effects that a player has active for client consumption
 * Aligned with PlayerActionDto structure for consistent behavior handling
 */
export interface PlayerEffectDto {
  cardId: string; // ID of the card that provides this effect
  cardName: string; // Name of the card for display purposes
  behaviorIndex: number /* int */; // Which behavior on the card this effect represents
  behavior: CardBehaviorDto; // The actual behavior definition with inputs/outputs
}
/**
 * PlayerActionDto represents an action that a player can take for client consumption
 * Enhanced with calculated usability state from Player-Scoped Card Architecture
 */
export interface PlayerActionDto {
  cardId: string; // ID of the card that provides this action
  cardName: string; // Name of the card for display purposes
  behaviorIndex: number /* int */; // Which behavior on the card this action represents
  behavior: CardBehaviorDto; // The actual behavior definition with inputs/outputs
  timesUsedThisTurn: number /* int */; // Times used this turn
  timesUsedThisGeneration: number /* int */; // Times used this generation
  available: boolean; // Computed: action is usable
  errors: StateErrorDto[]; // Reasons why action is not usable
}
/**
 * PlayerStandardProjectDto represents a standard project with availability state
 * Part of the Player-Scoped Card Architecture
 */
export interface PlayerStandardProjectDto {
  projectType: string; // Standard project type (e.g., "sell_patents", "aquifer")
  baseCost: { [key: string]: number /* int */ }; // Base cost per resource type (e.g., {"credits": 23} or {"plants": 8})
  available: boolean; // Computed: project is available
  errors: StateErrorDto[]; // Reasons why project is not available
  effectiveCost: { [key: string]: number /* int */ }; // Cost per resource type after discounts
  discounts?: { [key: string]: number /* int */ }; // Discount amounts per resource type (if any)
  metadata?: { [key: string]: any }; // Project-specific context (e.g., oceansRemaining)
}
/**
 * ForcedFirstActionDto represents an action that must be completed as the player's first turn action
 */
export interface ForcedFirstActionDto {
  actionType: string; // Type of action: "city_placement", "card_draw", etc.
  corporationId: string; // Corporation that requires this action
  completed: boolean; // Whether the forced action has been completed
  description: string; // Human-readable description for UI
}
/**
 * PendingTileSelectionDto represents a pending tile placement action for client consumption
 */
export interface PendingTileSelectionDto {
  tileType: string; // "city", "greenery", "ocean"
  availableHexes: string[]; // Backend-calculated valid hex coordinates
  source: string; // What triggered this selection (card ID, standard project, etc.)
}
/**
 * PendingCardSelectionDto represents a pending card selection action (e.g., sell patents, card effects)
 */
export interface PendingCardSelectionDto {
  availableCards: CardDto[]; // Card IDs player can select from
  cardCosts: { [key: string]: number /* int */ }; // Card ID -> cost to select (0 for sell patents, 3 for buying cards)
  cardRewards: { [key: string]: number /* int */ }; // Card ID -> reward for selecting (1 MC for sell patents)
  source: string; // What triggered this selection ("sell-patents", card ID, etc.)
  minCards: number /* int */; // Minimum cards to select (0 for sell patents)
  maxCards: number /* int */; // Maximum cards to select (hand size for sell patents)
}
/**
 * PendingCardDrawSelectionDto represents a pending card draw/peek/take/buy action from card effects
 */
export interface PendingCardDrawSelectionDto {
  availableCards: CardDto[]; // Cards shown to player (drawn or peeked)
  freeTakeCount: number /* int */; // Number of cards to take for free (mandatory for card-draw, 0 = optional)
  maxBuyCount: number /* int */; // Maximum cards to buy (optional, 0 = no buying allowed)
  cardBuyCost: number /* int */; // Cost per card when buying (typically 3 MC, 0 if no buying)
  source: string; // Card ID or action that triggered this
}
/**
 * PlayerStatus represents the current status of a player in the game
 */
export type PlayerStatus = string;
export const PlayerStatusSelectingStartingCards: PlayerStatus = "selecting-starting-cards";
export const PlayerStatusSelectingProductionCards: PlayerStatus = "selecting-production-cards";
export const PlayerStatusWaiting: PlayerStatus = "waiting";
export const PlayerStatusActive: PlayerStatus = "active";
/**
 * PlayerDto represents a player in the game for client consumption
 */
export interface PlayerDto {
  id: string;
  name: string;
  status: PlayerStatus;
  corporation?: CardDto;
  cards: PlayerCardDto[]; // Hand cards with playability state (Player-Scoped Architecture)
  resources: ResourcesDto;
  production: ProductionDto;
  terraformRating: number /* int */;
  playedCards: CardDto[]; // Full card details for all played cards
  passed: boolean;
  availableActions: number /* int */;
  isConnected: boolean;
  effects: PlayerEffectDto[]; // Active ongoing effects (discounts, special abilities, etc.)
  actions: PlayerActionDto[]; // Available actions from played cards with manual triggers
  standardProjects: PlayerStandardProjectDto[]; // Standard projects with availability state (Player-Scoped Architecture)
  milestones: PlayerMilestoneDto[]; // Milestones with player eligibility state
  awards: PlayerAwardDto[]; // Awards with player eligibility state
  selectStartingCardsPhase?: SelectStartingCardsPhaseDto;
  productionPhase?: ProductionPhaseDto;
  startingCards: CardDto[];
  pendingTileSelection?: PendingTileSelectionDto;
  pendingCardSelection?: PendingCardSelectionDto;
  pendingCardDrawSelection?: PendingCardDrawSelectionDto;
  forcedFirstAction?: ForcedFirstActionDto;
  resourceStorage: { [key: string]: number /* int */ };
  paymentSubstitutes: PaymentSubstituteDto[];
  generationalEvents: PlayerGenerationalEventEntryDto[];
  vpGranters: VPGranterDto[];
}
/**
 * OtherPlayerDto represents another player from the viewing player's perspective (limited data)
 */
export interface OtherPlayerDto {
  id: string;
  name: string;
  status: PlayerStatus;
  corporation?: CardDto;
  handCardCount: number /* int */; // Number of cards in hand (private)
  resources: ResourcesDto;
  production: ProductionDto;
  terraformRating: number /* int */;
  playedCards: CardDto[]; // Played cards are public - full card details
  passed: boolean;
  availableActions: number /* int */;
  isConnected: boolean;
  effects: PlayerEffectDto[];
  actions: PlayerActionDto[];
  selectStartingCardsPhase?: SelectStartingCardsOtherPlayerDto;
  productionPhase?: ProductionPhaseOtherPlayerDto;
  resourceStorage: { [key: string]: number /* int */ };
  paymentSubstitutes: PaymentSubstituteDto[];
}
/**
 * GameDto represents a game for client consumption (clean architecture)
 */
export interface GameDto {
  id: string;
  status: GameStatus;
  settings: GameSettingsDto;
  hostPlayerId: string;
  currentPhase: GamePhase;
  globalParameters: GlobalParametersDto;
  currentPlayer: PlayerDto; // Viewing player's full data
  otherPlayers: OtherPlayerDto[]; // Other players' limited data
  viewingPlayerId: string; // The player viewing this game state
  currentTurn?: string; // Whose turn it is (nullable)
  generation: number /* int */;
  turnOrder: string[]; // Turn order of all players in game
  board: BoardDto; // Game board with tiles and occupancy state
  paymentConstants: PaymentConstantsDto; // Conversion rates for alternative payments
  milestones: MilestoneDto[]; // All milestones with claim status
  awards: AwardDto[]; // All awards with funding status
  awardResults: AwardResultDto[]; // Current award placements (1st/2nd place per award)
  finalScores?: FinalScoreDto[]; // Final scores (only when game completed)
  triggeredEffects?: TriggeredEffectDto[]; // Recently triggered passive effects
}
/**
 * TileBonusDto represents a resource bonus provided by a tile when occupied
 */
export interface TileBonusDto {
  type: string;
  amount: number /* int */;
}
/**
 * TileOccupantDto represents what currently occupies a tile
 */
export interface TileOccupantDto {
  type: string;
  tags: string[];
}
/**
 * TileDto represents a single hexagonal tile on the game board
 */
export interface TileDto {
  coordinates: HexPositionDto;
  tags: string[];
  type: string;
  location: string;
  displayName?: string;
  bonuses: TileBonusDto[];
  occupiedBy?: TileOccupantDto;
  ownerId?: string;
}
/**
 * BoardDto represents the game board containing all tiles
 */
export interface BoardDto {
  tiles: TileDto[];
}
/**
 * MilestoneDto represents a milestone for client consumption
 */
export interface MilestoneDto {
  type: string;
  name: string;
  description: string;
  isClaimed: boolean;
  claimedBy?: string;
  claimCost: number /* int */;
}
/**
 * AwardDto represents an award for client consumption
 */
export interface AwardDto {
  type: string;
  name: string;
  description: string;
  isFunded: boolean;
  fundedBy?: string;
  fundingCost: number /* int */;
}
/**
 * AwardResultDto represents the placement results for a single funded award
 */
export interface AwardResultDto {
  awardType: string;
  firstPlaceIds: string[];
  secondPlaceIds: string[];
}
/**
 * PlayerMilestoneDto represents a milestone with player-specific eligibility state
 */
export interface PlayerMilestoneDto {
  type: string;
  name: string;
  description: string;
  claimCost: number /* int */;
  isClaimed: boolean;
  claimedBy?: string;
  available: boolean; // Can this player claim this milestone?
  progress: number /* int */; // Current progress towards requirement
  required: number /* int */; // Requirement threshold
  errors: StateErrorDto[]; // Reasons why not available
}
/**
 * PlayerAwardDto represents an award with player-specific eligibility state
 */
export interface PlayerAwardDto {
  type: string;
  name: string;
  description: string;
  fundingCost: number /* int */; // Current cost to fund (increases as more are funded)
  isFunded: boolean;
  fundedBy?: string;
  available: boolean; // Can this player fund this award?
  errors: StateErrorDto[]; // Reasons why not available
}
/**
 * VPGranterConditionDto represents a single VP condition's computed breakdown for client consumption
 */
export interface VPGranterConditionDto {
  amount: number /* int */;
  conditionType: string;
  perType?: string;
  perAmount?: number /* int */;
  count: number /* int */;
  computedVP: number /* int */;
  explanation: string;
}
/**
 * VPGranterDto represents a VP source from a played card or corporation for client consumption
 */
export interface VPGranterDto {
  cardId: string;
  cardName: string;
  description: string;
  computedValue: number /* int */;
  conditions: VPGranterConditionDto[];
}
/**
 * CardVPConditionDetailDto represents the detailed calculation of a single VP condition
 */
export interface CardVPConditionDetailDto {
  conditionType: string; // "fixed", "per", "once"
  amount: number /* int */; // VP amount per trigger or fixed amount
  count: number /* int */; // Items counted (for "per" conditions)
  maxTrigger?: number /* int */;
  actualTriggers: number /* int */; // Actual triggers after applying max
  totalVP: number /* int */; // Final VP from this condition
  explanation: string; // Human-readable breakdown
}
/**
 * CardVPDetailDto represents VP calculation for a single card
 */
export interface CardVPDetailDto {
  cardId: string;
  cardName: string;
  conditions: CardVPConditionDetailDto[];
  totalVP: number /* int */;
}
/**
 * GreeneryVPDetailDto represents VP from a single greenery tile
 */
export interface GreeneryVPDetailDto {
  coordinate: string; // Format: "q,r,s"
  vp: number /* int */; // Always 1 per greenery
}
/**
 * CityVPDetailDto represents VP from a single city tile and its adjacent greeneries
 */
export interface CityVPDetailDto {
  cityCoordinate: string; // Format: "q,r,s"
  adjacentGreeneries: string[]; // Coordinates of adjacent greenery tiles
  vp: number /* int */; // Number of adjacent greeneries
}
/**
 * VPBreakdownDto represents a breakdown of victory points for client consumption
 */
export interface VPBreakdownDto {
  terraformRating: number /* int */;
  cardVP: number /* int */;
  cardVPDetails: CardVPDetailDto[]; // Per-card VP breakdown
  milestoneVP: number /* int */;
  awardVP: number /* int */;
  greeneryVP: number /* int */;
  greeneryVPDetails: GreeneryVPDetailDto[]; // Per-greenery VP breakdown
  cityVP: number /* int */;
  cityVPDetails: CityVPDetailDto[]; // Per-city VP breakdown with adjacencies
  totalVP: number /* int */;
}
/**
 * FinalScoreDto represents a player's final score for client consumption
 */
export interface FinalScoreDto {
  playerId: string;
  playerName: string;
  vpBreakdown: VPBreakdownDto;
  isWinner: boolean;
  placement: number /* int */;
}
/**
 * TriggeredEffectDto represents a card effect that was triggered for client notification
 */
export interface TriggeredEffectDto {
  cardName: string;
  playerId: string;
  outputs: ResourceConditionDto[];
}
/**
 * GenerationalEvent represents events tracked within a generation for conditional card behaviors
 */
export type GenerationalEvent = string;
export const GenerationalEventTRRaise: GenerationalEvent = "tr-raise";
export const GenerationalEventOceanPlacement: GenerationalEvent = "ocean-placement";
export const GenerationalEventCityPlacement: GenerationalEvent = "city-placement";
export const GenerationalEventGreeneryPlacement: GenerationalEvent = "greenery-placement";
/**
 * PlayerGenerationalEventEntryDto represents a player's tracked generational event for client consumption
 */
export interface PlayerGenerationalEventEntryDto {
  event: GenerationalEvent;
  count: number /* int */;
}
/**
 * GenerationalEventRequirementDto represents a requirement based on generational events for card behaviors
 */
export interface GenerationalEventRequirementDto {
  event: GenerationalEvent;
  count?: MinMaxValueDto;
  target?: TargetType;
}

//////////
// source: http_dto.go

/**
 * CreateGameRequest represents the request body for creating a game
 */
export interface CreateGameRequest {
  maxPlayers: number /* int */;
  developmentMode: boolean;
  cardPacks?: string[];
}
/**
 * CreateGameResponse represents the response for creating a game
 */
export interface CreateGameResponse {
  game: GameDto;
}
/**
 * JoinGameRequest represents the request body for joining a game
 */
export interface JoinGameRequest {
  playerName: string;
}
/**
 * JoinGameResponse represents the response for joining a game
 */
export interface JoinGameResponse {
  game: GameDto;
  playerId: string;
}
/**
 * GetGameResponse represents the response for getting a game
 */
export interface GetGameResponse {
  game: GameDto;
}
/**
 * ListGamesResponse represents the response for listing games
 */
export interface ListGamesResponse {
  games: GameDto[];
}
/**
 * GetPlayerResponse represents the response for getting a player
 */
export interface GetPlayerResponse {
  player: PlayerDto;
}
/**
 * ListCardsResponse represents the response for listing cards with pagination
 */
export interface ListCardsResponse {
  cards: CardDto[];
  totalCount: number /* int */;
  offset: number /* int */;
  limit: number /* int */;
}
/**
 * ErrorResponse represents an error response
 */
export interface ErrorResponse {
  error: string;
  code?: string;
  details?: string;
}
/**
 * CreateDemoLobbyRequest represents the request body for creating a demo lobby
 */
export interface CreateDemoLobbyRequest {
  playerCount: number /* int */;
  cardPacks?: string[];
  playerName?: string;
}
/**
 * CreateDemoLobbyResponse represents the response for creating a demo lobby
 */
export interface CreateDemoLobbyResponse {
  game: GameDto;
  playerId: string;
}

//////////
// source: message_types.go

/**
 * MessageType represents different types of WebSocket messages
 */
export type MessageType = string;
export const MessageTypePlayerConnect: MessageType = "player-connect";
export const MessageTypeJoinGame: MessageType = "join-game";
export const MessageTypeGameUpdated: MessageType = "game-updated";
export const MessageTypePlayerConnected: MessageType = "player-connected";
export const MessageTypePlayerReconnected: MessageType = "player-reconnected";
export const MessageTypePlayerDisconnected: MessageType = "player-disconnected";
export const MessageTypeError: MessageType = "error";
export const MessageTypeFullState: MessageType = "full-state";
export const MessageTypeProductionPhaseStarted: MessageType = "production-phase-started";
export const MessageTypeActionSellPatents: MessageType = "action.standard-project.sell-patents";
export const MessageTypeActionConfirmSellPatents: MessageType =
  "action.standard-project.confirm-sell-patents";
export const MessageTypeActionLaunchAsteroid: MessageType =
  "action.standard-project.launch-asteroid";
export const MessageTypeActionBuildPowerPlant: MessageType =
  "action.standard-project.build-power-plant";
export const MessageTypeActionBuildAquifer: MessageType = "action.standard-project.build-aquifer";
export const MessageTypeActionPlantGreenery: MessageType = "action.standard-project.plant-greenery";
export const MessageTypeActionBuildCity: MessageType = "action.standard-project.build-city";
export const MessageTypeActionConvertPlantsToGreenery: MessageType =
  "action.resource-conversion.convert-plants-to-greenery";
export const MessageTypeActionConvertHeatToTemperature: MessageType =
  "action.resource-conversion.convert-heat-to-temperature";
export const MessageTypeCreateGame: MessageType = "create-game";
export const MessageTypeActionStartGame: MessageType = "action.game-management.start-game";
export const MessageTypeActionSkipAction: MessageType = "action.game-management.skip-action";
export const MessageTypeActionConfirmDemoSetup: MessageType =
  "action.game-management.confirm-demo-setup";
export const MessageTypeActionClaimMilestone: MessageType = "action.milestone.claim-milestone";
export const MessageTypeActionFundAward: MessageType = "action.award.fund-award";
export const MessageTypeActionTileSelected: MessageType = "action.tile-selection.tile-selected";
export const MessageTypeActionPlayCard: MessageType = "action.card.play-card";
export const MessageTypeActionCardAction: MessageType = "action.card.card-action";
export const MessageTypeActionSelectStartingCard: MessageType = "action.card.select-starting-card";
export const MessageTypeActionSelectCards: MessageType = "action.card.select-cards";
export const MessageTypeActionConfirmProductionCards: MessageType =
  "action.card.confirm-production-cards";
export const MessageTypeActionCardDrawConfirmed: MessageType = "action.card.card-draw-confirmed";
export const MessageTypeAdminCommand: MessageType = "admin-command";

//////////
// source: websocket_dto.go

/**
 * WebSocketMessage represents a WebSocket message
 */
export interface WebSocketMessage {
  type: MessageType;
  payload: any;
  gameId?: string;
}
/**
 * PlayerConnectPayload contains player connection data
 */
export interface PlayerConnectPayload {
  playerName: string;
  gameId: string;
  playerId?: string; // Optional: used for reconnection
}
/**
 * GameUpdatedPayload contains updated game state
 */
export interface GameUpdatedPayload {
  game: GameDto;
}
/**
 * PlayerConnectedPayload contains data about a newly connected player
 */
export interface PlayerConnectedPayload {
  playerId: string;
  playerName: string;
  game: GameDto;
}
/**
 * ErrorPayload contains error information
 */
export interface ErrorPayload {
  message: string;
  code?: string;
}
/**
 * FullStatePayload contains the complete game state
 */
export interface FullStatePayload {
  game: GameDto;
  playerId: string;
}
/**
 * PlayerReconnectedPayload contains data about a reconnected player
 */
export interface PlayerReconnectedPayload {
  playerId: string;
  playerName: string;
  game: GameDto;
}
/**
 * PlayerDisconnectedPayload contains data about a disconnected player (for internal handler use)
 */
export interface PlayerDisconnectedPayload {
  playerId: string;
  gameId: string;
}
/**
 * PlayerProductionData contains production data for a single player
 */
export interface PlayerProductionData {
  playerId: string;
  playerName: string;
  production: ProductionDto;
}
/**
 * ProductionPhaseStartedPayload contains data when production phase begins
 */
export interface ProductionPhaseStartedPayload {
  generation: number /* int */;
  playersData: PlayerProductionData[];
  game: GameDto;
}
/**
 * ConfirmStartingCardSelectionMessage represents confirm starting card selection message
 */
export interface ConfirmStartingCardSelectionMessage {
  gameId: string;
  playerId: string;
}
