# Implementation Plan: VP Calculations

**Branch**: `002-vp-calculations` | **Date**: 2026-01-30 | **Spec**: [spec.md](spec.md)
**Input**: Feature specification from `/specs/002-vp-calculations/spec.md`

## Summary

Implement live VP tracking with event-driven recalculation and an interactive breakdown modal. The backend adds a VPGranters component to the Player struct that registers VP sources when cards/corporations are played and recalculates computed values on relevant game events (CardPlayed, ResourceStorageChanged, TilePlaced, TagPlayed, CorporationSelected). The frontend replaces the existing VictoryPointsModal with a horizontal stacked bar showing per-card VP contributions with hover tooltips. Comprehensive tests cover all 10 VP condition types found in the card database (137 cards total).

## Technical Context

**Language/Version**: Go 1.21+ (backend), TypeScript 5.x (frontend)
**Primary Dependencies**: gorilla/websocket, chi router, React 18, Tailwind CSS v4
**Storage**: In-memory game state (no persistence)
**Testing**: `go test` with table-driven tests in `backend/test/`
**Target Platform**: Web (Linux server + browser client)
**Project Type**: Web application (Go backend + React frontend)
**Performance Goals**: VP recalculation within same event cycle (synchronous), no visible delay
**Constraints**: VP data sent only to self-player (not opponents during gameplay)
**Scale/Scope**: 137 cards with VP conditions across 10 condition types

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

| Principle | Status | Notes |
|-----------|--------|-------|
| I. Clean Architecture & Action Pattern | PASS | VP recalculation via event subscriptions in Game (same pattern as generational events). No business logic in handlers. State mutation through VPGranters component methods. |
| II. Code Clarity Over Comments | PASS | Self-documenting code with clear naming (VPGranter, ComputedValue, etc.). No explanatory comments needed. |
| III. Best Practices Enforcement | PASS | Will run `make format` and `make lint`. Follows Go idioms (table-driven tests, error handling). |
| IV. Complete Feature Implementation | PASS | All 10 VP condition types covered. Comprehensive test suite. Full modal rewrite. |
| V. Type Safety & Generation | PASS | New DTOs with `json:` and `ts:` tags. `make generate` for TypeScript types. |
| VI. Testing Discipline | PASS | Tests in `backend/test/` with table-driven scenarios covering all VP condition permutations. |
| VII. No Deprecated Code | PASS | Old VP modal logic completely replaced. No deprecated code retained. |

**Post-Phase 1 Re-check**: All principles satisfied. The VPGranters component follows the same pattern as GenerationalEvents (Player component with event subscriptions in Game).

## Project Structure

### Documentation (this feature)

```text
specs/002-vp-calculations/
├── plan.md              # This file
├── spec.md              # Feature specification
├── research.md          # Research findings
├── data-model.md        # Entity definitions
├── quickstart.md        # Development quickstart
├── contracts/           # WebSocket message contracts
│   └── websocket-messages.md
└── tasks.md             # Task breakdown (generated by /speckit.tasks)
```

### Source Code (repository root)

```text
backend/
├── internal/
│   ├── game/
│   │   ├── player/
│   │   │   ├── player.go                    # MODIFY: Add vpGranters field + accessor
│   │   │   └── player_vp_granters.go        # NEW: VPGranters component
│   │   ├── cards/
│   │   │   └── vp_calculator.go             # MODIFY: Include VPGranter totals in breakdown
│   │   └── game.go                          # MODIFY: Add subscribeToVPEvents()
│   └── delivery/
│       └── dto/
│           ├── game_dto.go                  # MODIFY: Add VPGranterDto types
│           └── mapper_game.go               # MODIFY: Map VP granters to DTO
└── test/
    └── game/
        └── player/
            └── player_vp_granters_test.go   # NEW: Comprehensive VP tests

frontend/
└── src/
    └── components/
        └── ui/
            └── modals/
                └── VictoryPointsModal.tsx    # REWRITE: Stacked bar design
```

**Structure Decision**: Existing web application structure (Go backend + React frontend). New files follow established patterns: player component in `player/`, tests in `test/game/player/`, DTOs in `delivery/dto/`.

## Implementation Phases

### Phase 1: Backend — VPGranters Component

**Goal**: Create the VPGranters player component with VP condition evaluation logic.

**Files**:
- `backend/internal/game/player/player_vp_granters.go` (NEW)

**Details**:
1. Define `VPGranter` struct with fields: CardID, CardName, Description, VPConditions, ComputedValue
2. Define `VPGranters` struct with mutex-protected granter list, eventBus, gameID, playerID
3. Implement methods:
   - `Add(granter VPGranter)` — append to list
   - `Prepend(granter VPGranter)` — prepend (for corporation)
   - `GetAll() []VPGranter` — return copy
   - `TotalComputedVP() int` — sum all ComputedValues
   - `RecalculateAll(player, board, cardRegistry)` — recompute all granter values using existing `evaluateVPConditionDetailed` logic from `vp_calculator.go`, then publish `VictoryPointsChangedEvent`
4. The recalculation reuses the existing `countPerCondition` function from `vp_calculator.go` for evaluating per-conditions (self-card resources, tags, tiles)

### Phase 2: Backend — Player Integration

**Goal**: Wire VPGranters into the Player struct and constructor.

**Files**:
- `backend/internal/game/player/player.go` (MODIFY)

**Details**:
1. Add `vpGranters *VPGranters` field to Player struct
2. Initialize in `NewPlayer()` constructor
3. Add `VPGranters() *VPGranters` accessor method

### Phase 3: Backend — Event Subscriptions

**Goal**: Register event handlers in Game that create VP sources and trigger recalculation.

**Files**:
- `backend/internal/game/game.go` (MODIFY)

**Details**:
1. Add `subscribeToVPEvents()` method, called from `NewGame()` (same pattern as `subscribeToGenerationalEvents()`)
2. Subscribe to `CardPlayedEvent`:
   - Look up card in CardRegistry
   - If card has non-empty VPConditions, create VPGranter and Add to player's VPGranters
   - Call RecalculateAll on the player's VPGranters
3. Subscribe to `CorporationSelectedEvent`:
   - Look up corporation card in CardRegistry
   - If corporation has VP conditions, create VPGranter and Prepend to player's VPGranters
   - Call RecalculateAll
4. Subscribe to `ResourceStorageChangedEvent`:
   - Call RecalculateAll on the affected player's VPGranters (resource count on a card changed)
5. Subscribe to `TilePlacedEvent`:
   - Call RecalculateAll on ALL players' VPGranters (tile placement can affect any player's tile-based VP)
6. Subscribe to `TagPlayedEvent`:
   - Call RecalculateAll on the affected player's VPGranters (tag count changed)

### Phase 4: Backend — DTOs and Mapping

**Goal**: Expose VP granter data to the frontend via the existing game state DTO.

**Files**:
- `backend/internal/delivery/dto/game_dto.go` (MODIFY)
- `backend/internal/delivery/dto/mapper_game.go` (MODIFY)

**Details**:
1. Add `VPGranterDto` and `VPGranterConditionDto` structs with `json:` and `ts:` tags
2. Add `VPGranters []VPGranterDto` field to `PlayerDto` (self-player only)
3. Add mapper function `toVPGranterDtos(granters []player.VPGranter) []VPGranterDto`
4. Call mapper in `toPlayerDto()` to include VP granters in player state
5. Run `make generate` to create TypeScript types

### Phase 5: Backend — Comprehensive Tests

**Goal**: Test all 10 VP condition types with table-driven tests.

**Files**:
- `backend/test/game/player/player_vp_granters_test.go` (NEW)

**Test Cases** (table-driven):

| Test | Condition Type | Card Example | Setup | Expected VP |
|------|---------------|-------------|-------|-------------|
| Fixed VP (1) | fixed | Dust Seals | Play card | 1 |
| Fixed VP (2) | fixed | Farming | Play card | 2 |
| Fixed VP (3) | fixed | Anti-Gravity Technology | Play card | 3 |
| Fixed VP (4) | fixed | Earth Elevator | Play card | 4 |
| Per animal (1:1) | per animal, self-card | Birds | 5 animals on card | 5 |
| Per animal (1:2) | per animal, self-card | Small Animals | 5 animals on card | 2 |
| Per microbe (1:2) | per microbe, self-card | Ants | 6 microbes on card | 3 |
| Per microbe (1:3) | per microbe, self-card | Decomposers | 9 microbes on card | 3 |
| Per microbe (1:4) | per microbe, self-card | Tardigrades | 8 microbes on card | 2 |
| Per floater (1:2) | per floater, self-card | Floating Habs | 6 floaters on card | 3 |
| Per floater (1:3) | per floater, self-card | Celestic (corp) | 9 floaters on card | 3 |
| Per science (2:2) | per science, self-card | Physics Complex | 4 science on card | 4 |
| Per asteroid (1:1) | per asteroid, self-card | Security Fleet | 3 asteroids on card | 3 |
| Per jovian tag (1:1) | per tag (jovian) | Ganymede Colony | 3 jovian tags played | 3 |
| Per city tile (1:1) | per city-tile | Commercial District | 2 adjacent cities | 2 |
| Per city tile (1:3) | per city-tile | Immigration Shuttles | 6 city tiles anywhere | 2 |
| Per ocean tile | per ocean-tile | Capital | 3 adjacent oceans | 3 |
| Per colony tile (1:2) | per colony-tile | Space Port Colony | 4 colony tiles | 2 |
| MaxTrigger cap | per science, maxTrigger:1 | Search For Life | 3+ science on card | 3 (capped) |
| MaxTrigger not met | per science, maxTrigger:1 | Search For Life | 2 science on card | 0 |
| Zero resources | per animal, self-card | Birds | 0 animals | 0 |
| Corporation VP | per animal (1:2), self-card | Arklight | 4 animals | 2 |
| Multiple conditions | mixed | Multiple cards | Various | Sum correct |
| Event: card played | integration | Birds | Play card, add animals | VP updates |
| Event: resource added | integration | Predators | Add animal | VP increments |
| Event: tag played | integration | Ganymede Colony | Play jovian card | VP increments |
| Event: tile placed | integration | Capital | Place ocean adjacent | VP updates |
| VP order preserved | ordering | Multiple cards | Play A then B | A before B in list |
| Corporation first | ordering | Arklight + cards | Select corp, play cards | Corp is first |

### Phase 6: Frontend — Type Generation and VP Modal Rewrite

**Goal**: Rewrite VictoryPointsModal with horizontal stacked bar and interactive hover.

**Files**:
- `frontend/src/components/ui/modals/VictoryPointsModal.tsx` (REWRITE)

**Details**:
1. Run `make generate` to get new `VPGranterDto` TypeScript types
2. Rewrite VictoryPointsModal:
   - Accept `vpGranters: VPGranterDto[]` and `totalVP: number` props (from game state)
   - Use `GameModal` with `theme="victoryPoints"`
   - Header shows total VP via `VictoryPointsDisplay`
   - Body contains:
     a. **Card name labels**: Row of small text labels right-aligned above each bar segment, positioned to align with segment boundaries
     b. **Horizontal stacked bar**: Single bar with segments proportional to each granter's `computedValue`
     c. **Color palette**: Array of 12+ curated colors (amber, teal, indigo, rose, emerald, violet, cyan, orange, fuchsia, lime, sky, pink) — each granter gets color by index
     d. **Hover interaction**: On segment hover, apply `brightness(1.2)` filter and show tooltip
     e. **Tooltip**: Positioned above/below hovered segment showing card name, description, VP breakdown (e.g., "3 VP — 1 per animal (3 animals)")
   - Segments with 0 VP are hidden from the bar (but could be listed separately)
3. Ensure the VP button that opens the modal passes VP granter data from game state

### Phase 7: Format, Lint, and Validate

**Goal**: Ensure all code passes quality gates.

**Steps**:
1. `make generate` — TypeScript types from Go structs
2. `make format` — Format all code
3. `make lint` — Pass all linters
4. `make test` — All tests pass
5. `make prepare-for-commit` — Final validation
